{"ast":null,"code":"import { isBaseMessage } from \"./base.js\";\nimport { HumanMessage, HumanMessageChunk } from \"./human.js\";\nimport { AIMessage, AIMessageChunk } from \"./ai.js\";\nimport { SystemMessage, SystemMessageChunk } from \"./system.js\";\nimport { ChatMessage, ChatMessageChunk } from \"./chat.js\";\nimport { FunctionMessage, FunctionMessageChunk } from \"./function.js\";\nimport { ToolMessage } from \"./tool.js\";\nexport function coerceMessageLikeToMessage(messageLike) {\n  if (typeof messageLike === \"string\") {\n    return new HumanMessage(messageLike);\n  } else if (isBaseMessage(messageLike)) {\n    return messageLike;\n  }\n  const [type, content] = messageLike;\n  if (type === \"human\" || type === \"user\") {\n    return new HumanMessage({\n      content\n    });\n  } else if (type === \"ai\" || type === \"assistant\") {\n    return new AIMessage({\n      content\n    });\n  } else if (type === \"system\") {\n    return new SystemMessage({\n      content\n    });\n  } else {\n    throw new Error(`Unable to coerce message from array: only human, AI, or system message coercion is currently supported.`);\n  }\n}\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\nexport function getBufferString(messages, humanPrefix = \"Human\", aiPrefix = \"AI\") {\n  const string_messages = [];\n  for (const m of messages) {\n    let role;\n    if (m._getType() === \"human\") {\n      role = humanPrefix;\n    } else if (m._getType() === \"ai\") {\n      role = aiPrefix;\n    } else if (m._getType() === \"system\") {\n      role = \"System\";\n    } else if (m._getType() === \"function\") {\n      role = \"Function\";\n    } else if (m._getType() === \"tool\") {\n      role = \"Tool\";\n    } else if (m._getType() === \"generic\") {\n      role = m.role;\n    } else {\n      throw new Error(`Got unsupported message type: ${m._getType()}`);\n    }\n    const nameStr = m.name ? `${m.name}, ` : \"\";\n    string_messages.push(`${role}: ${nameStr}${m.content}`);\n  }\n  return string_messages.join(\"\\n\");\n}\n/**\n * Maps messages from an older format (V1) to the current `StoredMessage`\n * format. If the message is already in the `StoredMessage` format, it is\n * returned as is. Otherwise, it transforms the V1 message into a\n * `StoredMessage`. This function is important for maintaining\n * compatibility with older message formats.\n */\nfunction mapV1MessageToStoredMessage(message) {\n  // TODO: Remove this mapper when we deprecate the old message format.\n  if (message.data !== undefined) {\n    return message;\n  } else {\n    const v1Message = message;\n    return {\n      type: v1Message.type,\n      data: {\n        content: v1Message.text,\n        role: v1Message.role,\n        name: undefined,\n        tool_call_id: undefined\n      }\n    };\n  }\n}\nexport function mapStoredMessageToChatMessage(message) {\n  const storedMessage = mapV1MessageToStoredMessage(message);\n  switch (storedMessage.type) {\n    case \"human\":\n      return new HumanMessage(storedMessage.data);\n    case \"ai\":\n      return new AIMessage(storedMessage.data);\n    case \"system\":\n      return new SystemMessage(storedMessage.data);\n    case \"function\":\n      if (storedMessage.data.name === undefined) {\n        throw new Error(\"Name must be defined for function messages\");\n      }\n      return new FunctionMessage(storedMessage.data);\n    case \"tool\":\n      if (storedMessage.data.tool_call_id === undefined) {\n        throw new Error(\"Tool call ID must be defined for tool messages\");\n      }\n      return new ToolMessage(storedMessage.data);\n    case \"chat\":\n      {\n        if (storedMessage.data.role === undefined) {\n          throw new Error(\"Role must be defined for chat messages\");\n        }\n        return new ChatMessage(storedMessage.data);\n      }\n    default:\n      throw new Error(`Got unexpected type: ${storedMessage.type}`);\n  }\n}\n/**\n * Transforms an array of `StoredMessage` instances into an array of\n * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`\n * function to ensure all messages are in the `StoredMessage` format, then\n * creates new instances of the appropriate `BaseMessage` subclass based\n * on the type of each message. This function is used to prepare stored\n * messages for use in a chat context.\n */\nexport function mapStoredMessagesToChatMessages(messages) {\n  return messages.map(mapStoredMessageToChatMessage);\n}\n/**\n * Transforms an array of `BaseMessage` instances into an array of\n * `StoredMessage` instances. It does this by calling the `toDict` method\n * on each `BaseMessage`, which returns a `StoredMessage`. This function\n * is used to prepare chat messages for storage.\n */\nexport function mapChatMessagesToStoredMessages(messages) {\n  return messages.map(message => message.toDict());\n}\nexport function convertToChunk(message) {\n  const type = message._getType();\n  if (type === \"human\") {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new HumanMessageChunk({\n      ...message\n    });\n  } else if (type === \"ai\") {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new AIMessageChunk({\n      ...message\n    });\n  } else if (type === \"system\") {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new SystemMessageChunk({\n      ...message\n    });\n  } else if (type === \"function\") {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new FunctionMessageChunk({\n      ...message\n    });\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  } else if (ChatMessage.isInstance(message)) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new ChatMessageChunk({\n      ...message\n    });\n  } else {\n    throw new Error(\"Unknown message type.\");\n  }\n}","map":{"version":3,"names":["isBaseMessage","HumanMessage","HumanMessageChunk","AIMessage","AIMessageChunk","SystemMessage","SystemMessageChunk","ChatMessage","ChatMessageChunk","FunctionMessage","FunctionMessageChunk","ToolMessage","coerceMessageLikeToMessage","messageLike","type","content","Error","getBufferString","messages","humanPrefix","aiPrefix","string_messages","m","role","_getType","nameStr","name","push","join","mapV1MessageToStoredMessage","message","data","undefined","v1Message","text","tool_call_id","mapStoredMessageToChatMessage","storedMessage","mapStoredMessagesToChatMessages","map","mapChatMessagesToStoredMessages","toDict","convertToChunk","isInstance"],"sources":["C:/Users/lucil/Gen-AI-Contest/FrontEnd/kridic-front/node_modules/@langchain/core/dist/messages/utils.js"],"sourcesContent":["import { isBaseMessage, } from \"./base.js\";\nimport { HumanMessage, HumanMessageChunk } from \"./human.js\";\nimport { AIMessage, AIMessageChunk } from \"./ai.js\";\nimport { SystemMessage, SystemMessageChunk } from \"./system.js\";\nimport { ChatMessage, ChatMessageChunk, } from \"./chat.js\";\nimport { FunctionMessage, FunctionMessageChunk, } from \"./function.js\";\nimport { ToolMessage } from \"./tool.js\";\nexport function coerceMessageLikeToMessage(messageLike) {\n    if (typeof messageLike === \"string\") {\n        return new HumanMessage(messageLike);\n    }\n    else if (isBaseMessage(messageLike)) {\n        return messageLike;\n    }\n    const [type, content] = messageLike;\n    if (type === \"human\" || type === \"user\") {\n        return new HumanMessage({ content });\n    }\n    else if (type === \"ai\" || type === \"assistant\") {\n        return new AIMessage({ content });\n    }\n    else if (type === \"system\") {\n        return new SystemMessage({ content });\n    }\n    else {\n        throw new Error(`Unable to coerce message from array: only human, AI, or system message coercion is currently supported.`);\n    }\n}\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\nexport function getBufferString(messages, humanPrefix = \"Human\", aiPrefix = \"AI\") {\n    const string_messages = [];\n    for (const m of messages) {\n        let role;\n        if (m._getType() === \"human\") {\n            role = humanPrefix;\n        }\n        else if (m._getType() === \"ai\") {\n            role = aiPrefix;\n        }\n        else if (m._getType() === \"system\") {\n            role = \"System\";\n        }\n        else if (m._getType() === \"function\") {\n            role = \"Function\";\n        }\n        else if (m._getType() === \"tool\") {\n            role = \"Tool\";\n        }\n        else if (m._getType() === \"generic\") {\n            role = m.role;\n        }\n        else {\n            throw new Error(`Got unsupported message type: ${m._getType()}`);\n        }\n        const nameStr = m.name ? `${m.name}, ` : \"\";\n        string_messages.push(`${role}: ${nameStr}${m.content}`);\n    }\n    return string_messages.join(\"\\n\");\n}\n/**\n * Maps messages from an older format (V1) to the current `StoredMessage`\n * format. If the message is already in the `StoredMessage` format, it is\n * returned as is. Otherwise, it transforms the V1 message into a\n * `StoredMessage`. This function is important for maintaining\n * compatibility with older message formats.\n */\nfunction mapV1MessageToStoredMessage(message) {\n    // TODO: Remove this mapper when we deprecate the old message format.\n    if (message.data !== undefined) {\n        return message;\n    }\n    else {\n        const v1Message = message;\n        return {\n            type: v1Message.type,\n            data: {\n                content: v1Message.text,\n                role: v1Message.role,\n                name: undefined,\n                tool_call_id: undefined,\n            },\n        };\n    }\n}\nexport function mapStoredMessageToChatMessage(message) {\n    const storedMessage = mapV1MessageToStoredMessage(message);\n    switch (storedMessage.type) {\n        case \"human\":\n            return new HumanMessage(storedMessage.data);\n        case \"ai\":\n            return new AIMessage(storedMessage.data);\n        case \"system\":\n            return new SystemMessage(storedMessage.data);\n        case \"function\":\n            if (storedMessage.data.name === undefined) {\n                throw new Error(\"Name must be defined for function messages\");\n            }\n            return new FunctionMessage(storedMessage.data);\n        case \"tool\":\n            if (storedMessage.data.tool_call_id === undefined) {\n                throw new Error(\"Tool call ID must be defined for tool messages\");\n            }\n            return new ToolMessage(storedMessage.data);\n        case \"chat\": {\n            if (storedMessage.data.role === undefined) {\n                throw new Error(\"Role must be defined for chat messages\");\n            }\n            return new ChatMessage(storedMessage.data);\n        }\n        default:\n            throw new Error(`Got unexpected type: ${storedMessage.type}`);\n    }\n}\n/**\n * Transforms an array of `StoredMessage` instances into an array of\n * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`\n * function to ensure all messages are in the `StoredMessage` format, then\n * creates new instances of the appropriate `BaseMessage` subclass based\n * on the type of each message. This function is used to prepare stored\n * messages for use in a chat context.\n */\nexport function mapStoredMessagesToChatMessages(messages) {\n    return messages.map(mapStoredMessageToChatMessage);\n}\n/**\n * Transforms an array of `BaseMessage` instances into an array of\n * `StoredMessage` instances. It does this by calling the `toDict` method\n * on each `BaseMessage`, which returns a `StoredMessage`. This function\n * is used to prepare chat messages for storage.\n */\nexport function mapChatMessagesToStoredMessages(messages) {\n    return messages.map((message) => message.toDict());\n}\nexport function convertToChunk(message) {\n    const type = message._getType();\n    if (type === \"human\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new HumanMessageChunk({ ...message });\n    }\n    else if (type === \"ai\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new AIMessageChunk({ ...message });\n    }\n    else if (type === \"system\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new SystemMessageChunk({ ...message });\n    }\n    else if (type === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new FunctionMessageChunk({ ...message });\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    }\n    else if (ChatMessage.isInstance(message)) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new ChatMessageChunk({ ...message });\n    }\n    else {\n        throw new Error(\"Unknown message type.\");\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}