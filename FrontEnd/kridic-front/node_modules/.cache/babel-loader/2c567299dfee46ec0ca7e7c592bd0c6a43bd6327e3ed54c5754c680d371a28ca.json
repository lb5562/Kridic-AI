{"ast":null,"code":"import { BaseTracer } from \"./base.js\";\nimport { IterableReadableStream } from \"../utils/stream.js\";\nimport { AIMessageChunk } from \"../messages/ai.js\";\nimport { GenerationChunk } from \"../outputs.js\";\nfunction assignName({\n  name,\n  serialized\n}) {\n  if (name !== undefined) {\n    return name;\n  }\n  if (serialized?.name !== undefined) {\n    return serialized.name;\n  } else if (serialized?.id !== undefined && Array.isArray(serialized?.id)) {\n    return serialized.id[serialized.id.length - 1];\n  }\n  return \"Unnamed\";\n}\nexport const isStreamEventsHandler = handler => handler.name === \"event_stream_tracer\";\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nexport class EventStreamCallbackHandler extends BaseTracer {\n  constructor(fields) {\n    super({\n      _awaitHandler: true,\n      ...fields\n    });\n    Object.defineProperty(this, \"autoClose\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"includeNames\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"includeTypes\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"includeTags\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"excludeNames\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"excludeTypes\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"excludeTags\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"runInfoMap\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Map()\n    });\n    Object.defineProperty(this, \"tappedPromises\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Map()\n    });\n    Object.defineProperty(this, \"transformStream\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"writer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"receiveStream\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"event_stream_tracer\"\n    });\n    this.autoClose = fields?.autoClose ?? true;\n    this.includeNames = fields?.includeNames;\n    this.includeTypes = fields?.includeTypes;\n    this.includeTags = fields?.includeTags;\n    this.excludeNames = fields?.excludeNames;\n    this.excludeTypes = fields?.excludeTypes;\n    this.excludeTags = fields?.excludeTags;\n    this.transformStream = new TransformStream();\n    this.writer = this.transformStream.writable.getWriter();\n    this.receiveStream = IterableReadableStream.fromReadableStream(this.transformStream.readable);\n  }\n  [Symbol.asyncIterator]() {\n    return this.receiveStream;\n  }\n  async persistRun(_run) {\n    // This is a legacy method only called once for an entire run tree\n    // and is therefore not useful here\n  }\n  _includeRun(run) {\n    const runTags = run.tags ?? [];\n    let include = this.includeNames === undefined && this.includeTags === undefined && this.includeTypes === undefined;\n    if (this.includeNames !== undefined) {\n      include = include || this.includeNames.includes(run.name);\n    }\n    if (this.includeTypes !== undefined) {\n      include = include || this.includeTypes.includes(run.runType);\n    }\n    if (this.includeTags !== undefined) {\n      include = include || runTags.find(tag => this.includeTags?.includes(tag)) !== undefined;\n    }\n    if (this.excludeNames !== undefined) {\n      include = include && !this.excludeNames.includes(run.name);\n    }\n    if (this.excludeTypes !== undefined) {\n      include = include && !this.excludeTypes.includes(run.runType);\n    }\n    if (this.excludeTags !== undefined) {\n      include = include && runTags.every(tag => !this.excludeTags?.includes(tag));\n    }\n    return include;\n  }\n  async *tapOutputIterable(runId, outputStream) {\n    const firstChunk = await outputStream.next();\n    if (firstChunk.done) {\n      return;\n    }\n    const runInfo = this.runInfoMap.get(runId);\n    // Run has finished, don't issue any stream events.\n    // An example of this is for runnables that use the default\n    // implementation of .stream(), which delegates to .invoke()\n    // and calls .onChainEnd() before passing it to the iterator.\n    if (runInfo === undefined) {\n      yield firstChunk.value;\n      return;\n    }\n    let tappedPromise = this.tappedPromises.get(runId);\n    // if we are the first to tap, issue stream events\n    if (tappedPromise === undefined) {\n      let tappedPromiseResolver;\n      tappedPromise = new Promise(resolve => {\n        tappedPromiseResolver = resolve;\n      });\n      this.tappedPromises.set(runId, tappedPromise);\n      try {\n        const event = {\n          event: `on_${runInfo.runType}_stream`,\n          run_id: runId,\n          name: runInfo.name,\n          tags: runInfo.tags,\n          metadata: runInfo.metadata,\n          data: {}\n        };\n        await this.send({\n          ...event,\n          data: {\n            chunk: firstChunk.value\n          }\n        }, runInfo);\n        yield firstChunk.value;\n        for await (const chunk of outputStream) {\n          // Don't yield tool and retriever stream events\n          if (runInfo.runType !== \"tool\" && runInfo.runType !== \"retriever\") {\n            await this.send({\n              ...event,\n              data: {\n                chunk\n              }\n            }, runInfo);\n          }\n          yield chunk;\n        }\n      } finally {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        tappedPromiseResolver();\n        // Don't delete from the promises map to keep track of which runs have been tapped.\n      }\n    } else {\n      // otherwise just pass through\n      yield firstChunk.value;\n      for await (const chunk of outputStream) {\n        yield chunk;\n      }\n    }\n  }\n  async send(payload, run) {\n    if (this._includeRun(run)) {\n      await this.writer.write(payload);\n    }\n  }\n  async sendEndEvent(payload, run) {\n    const tappedPromise = this.tappedPromises.get(payload.run_id);\n    if (tappedPromise !== undefined) {\n      void tappedPromise.then(() => {\n        void this.send(payload, run);\n      });\n    } else {\n      await this.send(payload, run);\n    }\n  }\n  async onLLMStart(run) {\n    const runName = assignName(run);\n    const runType = run.inputs.messages !== undefined ? \"chat_model\" : \"llm\";\n    const runInfo = {\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {},\n      name: runName,\n      runType,\n      inputs: run.inputs\n    };\n    this.runInfoMap.set(run.id, runInfo);\n    const eventName = `on_${runType}_start`;\n    await this.send({\n      event: eventName,\n      data: {\n        input: run.inputs\n      },\n      name: runName,\n      tags: run.tags ?? [],\n      run_id: run.id,\n      metadata: run.extra?.metadata ?? {}\n    }, runInfo);\n  }\n  async onLLMNewToken(run, token,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  kwargs) {\n    const runInfo = this.runInfoMap.get(run.id);\n    let chunk;\n    let eventName;\n    if (runInfo === undefined) {\n      throw new Error(`onLLMNewToken: Run ID ${run.id} not found in run map.`);\n    }\n    if (runInfo.runType === \"chat_model\") {\n      eventName = \"on_chat_model_stream\";\n      if (kwargs?.chunk === undefined) {\n        chunk = new AIMessageChunk({\n          content: token\n        });\n      } else {\n        chunk = kwargs.chunk.message;\n      }\n    } else if (runInfo.runType === \"llm\") {\n      eventName = \"on_llm_stream\";\n      if (kwargs?.chunk === undefined) {\n        chunk = new GenerationChunk({\n          text: token\n        });\n      } else {\n        chunk = kwargs.chunk;\n      }\n    } else {\n      throw new Error(`Unexpected run type ${runInfo.runType}`);\n    }\n    await this.send({\n      event: eventName,\n      data: {\n        chunk\n      },\n      run_id: run.id,\n      name: runInfo.name,\n      tags: runInfo.tags,\n      metadata: runInfo.metadata\n    }, runInfo);\n  }\n  async onLLMEnd(run) {\n    const runInfo = this.runInfoMap.get(run.id);\n    this.runInfoMap.delete(run.id);\n    let eventName;\n    if (runInfo === undefined) {\n      throw new Error(`onLLMEnd: Run ID ${run.id} not found in run map.`);\n    }\n    const generations = run.outputs?.generations;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let output;\n    if (runInfo.runType === \"chat_model\") {\n      for (const generation of generations ?? []) {\n        if (output !== undefined) {\n          break;\n        }\n        output = generation[0]?.message;\n      }\n      eventName = \"on_chat_model_end\";\n    } else if (runInfo.runType === \"llm\") {\n      output = {\n        generations: generations?.map(generation => {\n          return generation.map(chunk => {\n            return {\n              text: chunk.text,\n              generationInfo: chunk.generationInfo\n            };\n          });\n        }),\n        llmOutput: run.outputs?.llmOutput ?? {}\n      };\n      eventName = \"on_llm_end\";\n    } else {\n      throw new Error(`onLLMEnd: Unexpected run type: ${runInfo.runType}`);\n    }\n    await this.sendEndEvent({\n      event: eventName,\n      data: {\n        output,\n        input: runInfo.inputs\n      },\n      run_id: run.id,\n      name: runInfo.name,\n      tags: runInfo.tags,\n      metadata: runInfo.metadata\n    }, runInfo);\n  }\n  async onChainStart(run) {\n    const runName = assignName(run);\n    const runType = run.run_type ?? \"chain\";\n    const runInfo = {\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {},\n      name: runName,\n      runType: run.run_type\n    };\n    let eventData = {};\n    // Workaround Runnable core code not sending input when transform streaming.\n    if (run.inputs.input === \"\" && Object.keys(run.inputs).length === 1) {\n      eventData = {};\n      runInfo.inputs = {};\n    } else if (run.inputs.input !== undefined) {\n      eventData.input = run.inputs.input;\n      runInfo.inputs = run.inputs.input;\n    } else {\n      eventData.input = run.inputs;\n      runInfo.inputs = run.inputs;\n    }\n    this.runInfoMap.set(run.id, runInfo);\n    await this.send({\n      event: `on_${runType}_start`,\n      data: eventData,\n      name: runName,\n      tags: run.tags ?? [],\n      run_id: run.id,\n      metadata: run.extra?.metadata ?? {}\n    }, runInfo);\n  }\n  async onChainEnd(run) {\n    const runInfo = this.runInfoMap.get(run.id);\n    this.runInfoMap.delete(run.id);\n    if (runInfo === undefined) {\n      throw new Error(`onChainEnd: Run ID ${run.id} not found in run map.`);\n    }\n    const eventName = `on_${run.run_type}_end`;\n    const inputs = run.inputs ?? runInfo.inputs ?? {};\n    const outputs = run.outputs?.output ?? run.outputs;\n    const data = {\n      output: outputs,\n      input: inputs\n    };\n    if (inputs.input && Object.keys(inputs).length === 1) {\n      data.input = inputs.input;\n      runInfo.inputs = inputs.input;\n    }\n    await this.sendEndEvent({\n      event: eventName,\n      data,\n      run_id: run.id,\n      name: runInfo.name,\n      tags: runInfo.tags,\n      metadata: runInfo.metadata ?? {}\n    }, runInfo);\n  }\n  async onToolStart(run) {\n    const runName = assignName(run);\n    const runInfo = {\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {},\n      name: runName,\n      runType: \"tool\",\n      inputs: run.inputs ?? {}\n    };\n    this.runInfoMap.set(run.id, runInfo);\n    await this.send({\n      event: \"on_tool_start\",\n      data: {\n        input: run.inputs ?? {}\n      },\n      name: runName,\n      run_id: run.id,\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {}\n    }, runInfo);\n  }\n  async onToolEnd(run) {\n    const runInfo = this.runInfoMap.get(run.id);\n    this.runInfoMap.delete(run.id);\n    if (runInfo === undefined) {\n      throw new Error(`onToolEnd: Run ID ${run.id} not found in run map.`);\n    }\n    if (runInfo.inputs === undefined) {\n      throw new Error(`onToolEnd: Run ID ${run.id} is a tool call, and is expected to have traced inputs.`);\n    }\n    const output = run.outputs?.output === undefined ? run.outputs : run.outputs.output;\n    await this.sendEndEvent({\n      event: \"on_tool_end\",\n      data: {\n        output,\n        input: runInfo.inputs\n      },\n      run_id: run.id,\n      name: runInfo.name,\n      tags: runInfo.tags,\n      metadata: runInfo.metadata\n    }, runInfo);\n  }\n  async onRetrieverStart(run) {\n    const runName = assignName(run);\n    const runType = \"retriever\";\n    const runInfo = {\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {},\n      name: runName,\n      runType,\n      inputs: {\n        query: run.inputs.query\n      }\n    };\n    this.runInfoMap.set(run.id, runInfo);\n    await this.send({\n      event: \"on_retriever_start\",\n      data: {\n        input: {\n          query: run.inputs.query\n        }\n      },\n      name: runName,\n      tags: run.tags ?? [],\n      run_id: run.id,\n      metadata: run.extra?.metadata ?? {}\n    }, runInfo);\n  }\n  async onRetrieverEnd(run) {\n    const runInfo = this.runInfoMap.get(run.id);\n    this.runInfoMap.delete(run.id);\n    if (runInfo === undefined) {\n      throw new Error(`onRetrieverEnd: Run ID ${run.id} not found in run map.`);\n    }\n    await this.sendEndEvent({\n      event: \"on_retriever_end\",\n      data: {\n        output: run.outputs?.documents ?? run.outputs,\n        input: runInfo.inputs\n      },\n      run_id: run.id,\n      name: runInfo.name,\n      tags: runInfo.tags,\n      metadata: runInfo.metadata\n    }, runInfo);\n  }\n  async finish() {\n    const pendingPromises = [...this.tappedPromises.values()];\n    void Promise.all(pendingPromises).finally(() => {\n      void this.writer.close();\n    });\n  }\n}","map":{"version":3,"names":["BaseTracer","IterableReadableStream","AIMessageChunk","GenerationChunk","assignName","name","serialized","undefined","id","Array","isArray","length","isStreamEventsHandler","handler","EventStreamCallbackHandler","constructor","fields","_awaitHandler","Object","defineProperty","enumerable","configurable","writable","value","Map","autoClose","includeNames","includeTypes","includeTags","excludeNames","excludeTypes","excludeTags","transformStream","TransformStream","writer","getWriter","receiveStream","fromReadableStream","readable","Symbol","asyncIterator","persistRun","_run","_includeRun","run","runTags","tags","include","includes","runType","find","tag","every","tapOutputIterable","runId","outputStream","firstChunk","next","done","runInfo","runInfoMap","get","tappedPromise","tappedPromises","tappedPromiseResolver","Promise","resolve","set","event","run_id","metadata","data","send","chunk","payload","write","sendEndEvent","then","onLLMStart","runName","inputs","messages","extra","eventName","input","onLLMNewToken","token","kwargs","Error","content","message","text","onLLMEnd","delete","generations","outputs","output","generation","map","generationInfo","llmOutput","onChainStart","run_type","eventData","keys","onChainEnd","onToolStart","onToolEnd","onRetrieverStart","query","onRetrieverEnd","documents","finish","pendingPromises","values","all","finally","close"],"sources":["C:/Users/lucil/Gen-AI-Contest/FrontEnd/kridic-front/node_modules/@langchain/core/dist/tracers/event_stream.js"],"sourcesContent":["import { BaseTracer } from \"./base.js\";\nimport { IterableReadableStream } from \"../utils/stream.js\";\nimport { AIMessageChunk } from \"../messages/ai.js\";\nimport { GenerationChunk } from \"../outputs.js\";\nfunction assignName({ name, serialized, }) {\n    if (name !== undefined) {\n        return name;\n    }\n    if (serialized?.name !== undefined) {\n        return serialized.name;\n    }\n    else if (serialized?.id !== undefined && Array.isArray(serialized?.id)) {\n        return serialized.id[serialized.id.length - 1];\n    }\n    return \"Unnamed\";\n}\nexport const isStreamEventsHandler = (handler) => handler.name === \"event_stream_tracer\";\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nexport class EventStreamCallbackHandler extends BaseTracer {\n    constructor(fields) {\n        super({ _awaitHandler: true, ...fields });\n        Object.defineProperty(this, \"autoClose\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"includeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"runInfoMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"tappedPromises\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"transformStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"writer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"receiveStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"event_stream_tracer\"\n        });\n        this.autoClose = fields?.autoClose ?? true;\n        this.includeNames = fields?.includeNames;\n        this.includeTypes = fields?.includeTypes;\n        this.includeTags = fields?.includeTags;\n        this.excludeNames = fields?.excludeNames;\n        this.excludeTypes = fields?.excludeTypes;\n        this.excludeTags = fields?.excludeTags;\n        this.transformStream = new TransformStream();\n        this.writer = this.transformStream.writable.getWriter();\n        this.receiveStream = IterableReadableStream.fromReadableStream(this.transformStream.readable);\n    }\n    [Symbol.asyncIterator]() {\n        return this.receiveStream;\n    }\n    async persistRun(_run) {\n        // This is a legacy method only called once for an entire run tree\n        // and is therefore not useful here\n    }\n    _includeRun(run) {\n        const runTags = run.tags ?? [];\n        let include = this.includeNames === undefined &&\n            this.includeTags === undefined &&\n            this.includeTypes === undefined;\n        if (this.includeNames !== undefined) {\n            include = include || this.includeNames.includes(run.name);\n        }\n        if (this.includeTypes !== undefined) {\n            include = include || this.includeTypes.includes(run.runType);\n        }\n        if (this.includeTags !== undefined) {\n            include =\n                include ||\n                    runTags.find((tag) => this.includeTags?.includes(tag)) !== undefined;\n        }\n        if (this.excludeNames !== undefined) {\n            include = include && !this.excludeNames.includes(run.name);\n        }\n        if (this.excludeTypes !== undefined) {\n            include = include && !this.excludeTypes.includes(run.runType);\n        }\n        if (this.excludeTags !== undefined) {\n            include =\n                include && runTags.every((tag) => !this.excludeTags?.includes(tag));\n        }\n        return include;\n    }\n    async *tapOutputIterable(runId, outputStream) {\n        const firstChunk = await outputStream.next();\n        if (firstChunk.done) {\n            return;\n        }\n        const runInfo = this.runInfoMap.get(runId);\n        // Run has finished, don't issue any stream events.\n        // An example of this is for runnables that use the default\n        // implementation of .stream(), which delegates to .invoke()\n        // and calls .onChainEnd() before passing it to the iterator.\n        if (runInfo === undefined) {\n            yield firstChunk.value;\n            return;\n        }\n        let tappedPromise = this.tappedPromises.get(runId);\n        // if we are the first to tap, issue stream events\n        if (tappedPromise === undefined) {\n            let tappedPromiseResolver;\n            tappedPromise = new Promise((resolve) => {\n                tappedPromiseResolver = resolve;\n            });\n            this.tappedPromises.set(runId, tappedPromise);\n            try {\n                const event = {\n                    event: `on_${runInfo.runType}_stream`,\n                    run_id: runId,\n                    name: runInfo.name,\n                    tags: runInfo.tags,\n                    metadata: runInfo.metadata,\n                    data: {},\n                };\n                await this.send({\n                    ...event,\n                    data: { chunk: firstChunk.value },\n                }, runInfo);\n                yield firstChunk.value;\n                for await (const chunk of outputStream) {\n                    // Don't yield tool and retriever stream events\n                    if (runInfo.runType !== \"tool\" && runInfo.runType !== \"retriever\") {\n                        await this.send({\n                            ...event,\n                            data: {\n                                chunk,\n                            },\n                        }, runInfo);\n                    }\n                    yield chunk;\n                }\n            }\n            finally {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tappedPromiseResolver();\n                // Don't delete from the promises map to keep track of which runs have been tapped.\n            }\n        }\n        else {\n            // otherwise just pass through\n            yield firstChunk.value;\n            for await (const chunk of outputStream) {\n                yield chunk;\n            }\n        }\n    }\n    async send(payload, run) {\n        if (this._includeRun(run)) {\n            await this.writer.write(payload);\n        }\n    }\n    async sendEndEvent(payload, run) {\n        const tappedPromise = this.tappedPromises.get(payload.run_id);\n        if (tappedPromise !== undefined) {\n            void tappedPromise.then(() => {\n                void this.send(payload, run);\n            });\n        }\n        else {\n            await this.send(payload, run);\n        }\n    }\n    async onLLMStart(run) {\n        const runName = assignName(run);\n        const runType = run.inputs.messages !== undefined ? \"chat_model\" : \"llm\";\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType,\n            inputs: run.inputs,\n        };\n        this.runInfoMap.set(run.id, runInfo);\n        const eventName = `on_${runType}_start`;\n        await this.send({\n            event: eventName,\n            data: {\n                input: run.inputs,\n            },\n            name: runName,\n            tags: run.tags ?? [],\n            run_id: run.id,\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onLLMNewToken(run, token, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    kwargs) {\n        const runInfo = this.runInfoMap.get(run.id);\n        let chunk;\n        let eventName;\n        if (runInfo === undefined) {\n            throw new Error(`onLLMNewToken: Run ID ${run.id} not found in run map.`);\n        }\n        if (runInfo.runType === \"chat_model\") {\n            eventName = \"on_chat_model_stream\";\n            if (kwargs?.chunk === undefined) {\n                chunk = new AIMessageChunk({ content: token });\n            }\n            else {\n                chunk = kwargs.chunk.message;\n            }\n        }\n        else if (runInfo.runType === \"llm\") {\n            eventName = \"on_llm_stream\";\n            if (kwargs?.chunk === undefined) {\n                chunk = new GenerationChunk({ text: token });\n            }\n            else {\n                chunk = kwargs.chunk;\n            }\n        }\n        else {\n            throw new Error(`Unexpected run type ${runInfo.runType}`);\n        }\n        await this.send({\n            event: eventName,\n            data: {\n                chunk,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    async onLLMEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        let eventName;\n        if (runInfo === undefined) {\n            throw new Error(`onLLMEnd: Run ID ${run.id} not found in run map.`);\n        }\n        const generations = run.outputs?.generations;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let output;\n        if (runInfo.runType === \"chat_model\") {\n            for (const generation of generations ?? []) {\n                if (output !== undefined) {\n                    break;\n                }\n                output = generation[0]?.message;\n            }\n            eventName = \"on_chat_model_end\";\n        }\n        else if (runInfo.runType === \"llm\") {\n            output = {\n                generations: generations?.map((generation) => {\n                    return generation.map((chunk) => {\n                        return {\n                            text: chunk.text,\n                            generationInfo: chunk.generationInfo,\n                        };\n                    });\n                }),\n                llmOutput: run.outputs?.llmOutput ?? {},\n            };\n            eventName = \"on_llm_end\";\n        }\n        else {\n            throw new Error(`onLLMEnd: Unexpected run type: ${runInfo.runType}`);\n        }\n        await this.sendEndEvent({\n            event: eventName,\n            data: {\n                output,\n                input: runInfo.inputs,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    async onChainStart(run) {\n        const runName = assignName(run);\n        const runType = run.run_type ?? \"chain\";\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType: run.run_type,\n        };\n        let eventData = {};\n        // Workaround Runnable core code not sending input when transform streaming.\n        if (run.inputs.input === \"\" && Object.keys(run.inputs).length === 1) {\n            eventData = {};\n            runInfo.inputs = {};\n        }\n        else if (run.inputs.input !== undefined) {\n            eventData.input = run.inputs.input;\n            runInfo.inputs = run.inputs.input;\n        }\n        else {\n            eventData.input = run.inputs;\n            runInfo.inputs = run.inputs;\n        }\n        this.runInfoMap.set(run.id, runInfo);\n        await this.send({\n            event: `on_${runType}_start`,\n            data: eventData,\n            name: runName,\n            tags: run.tags ?? [],\n            run_id: run.id,\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onChainEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        if (runInfo === undefined) {\n            throw new Error(`onChainEnd: Run ID ${run.id} not found in run map.`);\n        }\n        const eventName = `on_${run.run_type}_end`;\n        const inputs = run.inputs ?? runInfo.inputs ?? {};\n        const outputs = run.outputs?.output ?? run.outputs;\n        const data = {\n            output: outputs,\n            input: inputs,\n        };\n        if (inputs.input && Object.keys(inputs).length === 1) {\n            data.input = inputs.input;\n            runInfo.inputs = inputs.input;\n        }\n        await this.sendEndEvent({\n            event: eventName,\n            data,\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata ?? {},\n        }, runInfo);\n    }\n    async onToolStart(run) {\n        const runName = assignName(run);\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType: \"tool\",\n            inputs: run.inputs ?? {},\n        };\n        this.runInfoMap.set(run.id, runInfo);\n        await this.send({\n            event: \"on_tool_start\",\n            data: {\n                input: run.inputs ?? {},\n            },\n            name: runName,\n            run_id: run.id,\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onToolEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        if (runInfo === undefined) {\n            throw new Error(`onToolEnd: Run ID ${run.id} not found in run map.`);\n        }\n        if (runInfo.inputs === undefined) {\n            throw new Error(`onToolEnd: Run ID ${run.id} is a tool call, and is expected to have traced inputs.`);\n        }\n        const output = run.outputs?.output === undefined ? run.outputs : run.outputs.output;\n        await this.sendEndEvent({\n            event: \"on_tool_end\",\n            data: {\n                output,\n                input: runInfo.inputs,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    async onRetrieverStart(run) {\n        const runName = assignName(run);\n        const runType = \"retriever\";\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType,\n            inputs: {\n                query: run.inputs.query,\n            },\n        };\n        this.runInfoMap.set(run.id, runInfo);\n        await this.send({\n            event: \"on_retriever_start\",\n            data: {\n                input: {\n                    query: run.inputs.query,\n                },\n            },\n            name: runName,\n            tags: run.tags ?? [],\n            run_id: run.id,\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onRetrieverEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        if (runInfo === undefined) {\n            throw new Error(`onRetrieverEnd: Run ID ${run.id} not found in run map.`);\n        }\n        await this.sendEndEvent({\n            event: \"on_retriever_end\",\n            data: {\n                output: run.outputs?.documents ?? run.outputs,\n                input: runInfo.inputs,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    async finish() {\n        const pendingPromises = [...this.tappedPromises.values()];\n        void Promise.all(pendingPromises).finally(() => {\n            void this.writer.close();\n        });\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}