{"ast":null,"code":"/* eslint-disable prefer-template */\n/* eslint-disable default-case */\n/* eslint-disable no-plusplus */\n// Adapted from https://github.com/gfortaine/fetch-event-source/blob/main/src/parse.ts\n// due to a packaging issue in the original.\n// MIT License\nimport { IterableReadableStream } from \"./stream.js\";\nexport const EventStreamContentType = \"text/event-stream\";\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nexport async function getBytes(stream, onChunk) {\n  const reader = stream.getReader();\n  // CHANGED: Introduced a \"flush\" mechanism to process potential pending messages when the stream ends.\n  //          This change is essential to ensure that we capture every last piece of information from streams,\n  //          such as those from Azure OpenAI, which may not terminate with a blank line. Without this\n  //          mechanism, we risk ignoring a possibly significant last message.\n  //          See https://github.com/langchain-ai/langchainjs/issues/1299 for details.\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const result = await reader.read();\n    if (result.done) {\n      onChunk(new Uint8Array(), true);\n      break;\n    }\n    onChunk(result.value);\n  }\n}\n/**\n * Parses arbitary byte chunks into EventSource line buffers.\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\n * @param onLine A function that will be called on each new EventSource line.\n * @returns A function that should be called for each incoming byte chunk.\n */\nexport function getLines(onLine) {\n  let buffer;\n  let position; // current read position\n  let fieldLength; // length of the `field` portion of the line\n  let discardTrailingNewline = false;\n  // return a function that can process each incoming byte chunk:\n  return function onChunk(arr, flush) {\n    if (flush) {\n      onLine(arr, 0, true);\n      return;\n    }\n    if (buffer === undefined) {\n      buffer = arr;\n      position = 0;\n      fieldLength = -1;\n    } else {\n      // we're still parsing the old line. Append the new bytes into buffer:\n      buffer = concat(buffer, arr);\n    }\n    const bufLength = buffer.length;\n    let lineStart = 0; // index where the current line starts\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === 10 /* ControlChars.NewLine */) {\n          lineStart = ++position; // skip to next char\n        }\n        discardTrailingNewline = false;\n      }\n      // start looking forward till the end of line:\n      let lineEnd = -1; // index of the \\r or \\n char\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case 58 /* ControlChars.Colon */:\n            if (fieldLength === -1) {\n              // first colon in line\n              fieldLength = position - lineStart;\n            }\n            break;\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n          case 13 /* ControlChars.CarriageReturn */:\n            discardTrailingNewline = true;\n          // eslint-disable-next-line no-fallthrough\n          case 10 /* ControlChars.NewLine */:\n            lineEnd = position;\n            break;\n        }\n      }\n      if (lineEnd === -1) {\n        // We reached the end of the buffer but the line hasn't ended.\n        // Wait for the next arr and then continue parsing:\n        break;\n      }\n      // we've reached the line end, send it out:\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n      lineStart = position; // we're now on the next line\n      fieldLength = -1;\n    }\n    if (lineStart === bufLength) {\n      buffer = undefined; // we've finished reading it\n    } else if (lineStart !== 0) {\n      // Create a new view into buffer beginning at lineStart so we don't\n      // need to copy over the previous lines when we get the new arr:\n      buffer = buffer.subarray(lineStart);\n      position -= lineStart;\n    }\n  };\n}\n/**\n * Parses line buffers into EventSourceMessages.\n * @param onId A function that will be called on each `id` field.\n * @param onRetry A function that will be called on each `retry` field.\n * @param onMessage A function that will be called on each message.\n * @returns A function that should be called for each incoming line buffer.\n */\nexport function getMessages(onMessage, onId, onRetry) {\n  let message = newMessage();\n  const decoder = new TextDecoder();\n  // return a function that can process each incoming line buffer:\n  return function onLine(line, fieldLength, flush) {\n    if (flush) {\n      if (!isEmpty(message)) {\n        onMessage?.(message);\n        message = newMessage();\n      }\n      return;\n    }\n    if (line.length === 0) {\n      // empty line denotes end of message. Trigger the callback and start a new message:\n      onMessage?.(message);\n      message = newMessage();\n    } else if (fieldLength > 0) {\n      // exclude comments and lines with no values\n      // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n      // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n      const field = decoder.decode(line.subarray(0, fieldLength));\n      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 /* ControlChars.Space */ ? 2 : 1);\n      const value = decoder.decode(line.subarray(valueOffset));\n      switch (field) {\n        case \"data\":\n          // if this message already has data, append the new value to the old.\n          // otherwise, just set to the new value:\n          message.data = message.data ? message.data + \"\\n\" + value : value; // otherwise,\n          break;\n        case \"event\":\n          message.event = value;\n          break;\n        case \"id\":\n          onId?.(message.id = value);\n          break;\n        case \"retry\":\n          {\n            const retry = parseInt(value, 10);\n            if (!Number.isNaN(retry)) {\n              // per spec, ignore non-integers\n              onRetry?.(message.retry = retry);\n            }\n            break;\n          }\n      }\n    }\n  };\n}\nfunction concat(a, b) {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\nfunction newMessage() {\n  // data, event, and id must be initialized to empty strings:\n  // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n  // retry should be initialized to undefined so we return a consistent shape\n  // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n  return {\n    data: \"\",\n    event: \"\",\n    id: \"\",\n    retry: undefined\n  };\n}\nexport function convertEventStreamToIterableReadableDataStream(stream, onMetadataEvent) {\n  const dataStream = new ReadableStream({\n    async start(controller) {\n      const enqueueLine = getMessages(msg => {\n        if (msg.event === \"error\") {\n          throw new Error(msg.data ?? \"Unspecified event streaming error.\");\n        } else if (msg.event === \"metadata\") {\n          onMetadataEvent?.(msg);\n        } else {\n          if (msg.data) controller.enqueue(msg.data);\n        }\n      });\n      const onLine = (line, fieldLength, flush) => {\n        enqueueLine(line, fieldLength, flush);\n        if (flush) controller.close();\n      };\n      await getBytes(stream, getLines(onLine));\n    }\n  });\n  return IterableReadableStream.fromReadableStream(dataStream);\n}\nfunction isEmpty(message) {\n  return message.data === \"\" && message.event === \"\" && message.id === \"\" && message.retry === undefined;\n}","map":{"version":3,"names":["IterableReadableStream","EventStreamContentType","getBytes","stream","onChunk","reader","getReader","result","read","done","Uint8Array","value","getLines","onLine","buffer","position","fieldLength","discardTrailingNewline","arr","flush","undefined","concat","bufLength","length","lineStart","lineEnd","subarray","getMessages","onMessage","onId","onRetry","message","newMessage","decoder","TextDecoder","line","isEmpty","field","decode","valueOffset","data","event","id","retry","parseInt","Number","isNaN","a","b","res","set","convertEventStreamToIterableReadableDataStream","onMetadataEvent","dataStream","ReadableStream","start","controller","enqueueLine","msg","Error","enqueue","close","fromReadableStream"],"sources":["C:/Users/lucil/Gen-AI-Contest/FrontEnd/kridic-front/node_modules/@langchain/core/dist/utils/event_source_parse.js"],"sourcesContent":["/* eslint-disable prefer-template */\n/* eslint-disable default-case */\n/* eslint-disable no-plusplus */\n// Adapted from https://github.com/gfortaine/fetch-event-source/blob/main/src/parse.ts\n// due to a packaging issue in the original.\n// MIT License\nimport { IterableReadableStream } from \"./stream.js\";\nexport const EventStreamContentType = \"text/event-stream\";\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nexport async function getBytes(stream, onChunk) {\n    const reader = stream.getReader();\n    // CHANGED: Introduced a \"flush\" mechanism to process potential pending messages when the stream ends.\n    //          This change is essential to ensure that we capture every last piece of information from streams,\n    //          such as those from Azure OpenAI, which may not terminate with a blank line. Without this\n    //          mechanism, we risk ignoring a possibly significant last message.\n    //          See https://github.com/langchain-ai/langchainjs/issues/1299 for details.\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const result = await reader.read();\n        if (result.done) {\n            onChunk(new Uint8Array(), true);\n            break;\n        }\n        onChunk(result.value);\n    }\n}\n/**\n * Parses arbitary byte chunks into EventSource line buffers.\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\n * @param onLine A function that will be called on each new EventSource line.\n * @returns A function that should be called for each incoming byte chunk.\n */\nexport function getLines(onLine) {\n    let buffer;\n    let position; // current read position\n    let fieldLength; // length of the `field` portion of the line\n    let discardTrailingNewline = false;\n    // return a function that can process each incoming byte chunk:\n    return function onChunk(arr, flush) {\n        if (flush) {\n            onLine(arr, 0, true);\n            return;\n        }\n        if (buffer === undefined) {\n            buffer = arr;\n            position = 0;\n            fieldLength = -1;\n        }\n        else {\n            // we're still parsing the old line. Append the new bytes into buffer:\n            buffer = concat(buffer, arr);\n        }\n        const bufLength = buffer.length;\n        let lineStart = 0; // index where the current line starts\n        while (position < bufLength) {\n            if (discardTrailingNewline) {\n                if (buffer[position] === 10 /* ControlChars.NewLine */) {\n                    lineStart = ++position; // skip to next char\n                }\n                discardTrailingNewline = false;\n            }\n            // start looking forward till the end of line:\n            let lineEnd = -1; // index of the \\r or \\n char\n            for (; position < bufLength && lineEnd === -1; ++position) {\n                switch (buffer[position]) {\n                    case 58 /* ControlChars.Colon */:\n                        if (fieldLength === -1) {\n                            // first colon in line\n                            fieldLength = position - lineStart;\n                        }\n                        break;\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n                    case 13 /* ControlChars.CarriageReturn */:\n                        discardTrailingNewline = true;\n                    // eslint-disable-next-line no-fallthrough\n                    case 10 /* ControlChars.NewLine */:\n                        lineEnd = position;\n                        break;\n                }\n            }\n            if (lineEnd === -1) {\n                // We reached the end of the buffer but the line hasn't ended.\n                // Wait for the next arr and then continue parsing:\n                break;\n            }\n            // we've reached the line end, send it out:\n            onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n            lineStart = position; // we're now on the next line\n            fieldLength = -1;\n        }\n        if (lineStart === bufLength) {\n            buffer = undefined; // we've finished reading it\n        }\n        else if (lineStart !== 0) {\n            // Create a new view into buffer beginning at lineStart so we don't\n            // need to copy over the previous lines when we get the new arr:\n            buffer = buffer.subarray(lineStart);\n            position -= lineStart;\n        }\n    };\n}\n/**\n * Parses line buffers into EventSourceMessages.\n * @param onId A function that will be called on each `id` field.\n * @param onRetry A function that will be called on each `retry` field.\n * @param onMessage A function that will be called on each message.\n * @returns A function that should be called for each incoming line buffer.\n */\nexport function getMessages(onMessage, onId, onRetry) {\n    let message = newMessage();\n    const decoder = new TextDecoder();\n    // return a function that can process each incoming line buffer:\n    return function onLine(line, fieldLength, flush) {\n        if (flush) {\n            if (!isEmpty(message)) {\n                onMessage?.(message);\n                message = newMessage();\n            }\n            return;\n        }\n        if (line.length === 0) {\n            // empty line denotes end of message. Trigger the callback and start a new message:\n            onMessage?.(message);\n            message = newMessage();\n        }\n        else if (fieldLength > 0) {\n            // exclude comments and lines with no values\n            // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n            // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n            const field = decoder.decode(line.subarray(0, fieldLength));\n            const valueOffset = fieldLength + (line[fieldLength + 1] === 32 /* ControlChars.Space */ ? 2 : 1);\n            const value = decoder.decode(line.subarray(valueOffset));\n            switch (field) {\n                case \"data\":\n                    // if this message already has data, append the new value to the old.\n                    // otherwise, just set to the new value:\n                    message.data = message.data ? message.data + \"\\n\" + value : value; // otherwise,\n                    break;\n                case \"event\":\n                    message.event = value;\n                    break;\n                case \"id\":\n                    onId?.((message.id = value));\n                    break;\n                case \"retry\": {\n                    const retry = parseInt(value, 10);\n                    if (!Number.isNaN(retry)) {\n                        // per spec, ignore non-integers\n                        onRetry?.((message.retry = retry));\n                    }\n                    break;\n                }\n            }\n        }\n    };\n}\nfunction concat(a, b) {\n    const res = new Uint8Array(a.length + b.length);\n    res.set(a);\n    res.set(b, a.length);\n    return res;\n}\nfunction newMessage() {\n    // data, event, and id must be initialized to empty strings:\n    // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n    // retry should be initialized to undefined so we return a consistent shape\n    // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n    return {\n        data: \"\",\n        event: \"\",\n        id: \"\",\n        retry: undefined,\n    };\n}\nexport function convertEventStreamToIterableReadableDataStream(stream, onMetadataEvent) {\n    const dataStream = new ReadableStream({\n        async start(controller) {\n            const enqueueLine = getMessages((msg) => {\n                if (msg.event === \"error\") {\n                    throw new Error(msg.data ?? \"Unspecified event streaming error.\");\n                }\n                else if (msg.event === \"metadata\") {\n                    onMetadataEvent?.(msg);\n                }\n                else {\n                    if (msg.data)\n                        controller.enqueue(msg.data);\n                }\n            });\n            const onLine = (line, fieldLength, flush) => {\n                enqueueLine(line, fieldLength, flush);\n                if (flush)\n                    controller.close();\n            };\n            await getBytes(stream, getLines(onLine));\n        },\n    });\n    return IterableReadableStream.fromReadableStream(dataStream);\n}\nfunction isEmpty(message) {\n    return (message.data === \"\" &&\n        message.event === \"\" &&\n        message.id === \"\" &&\n        message.retry === undefined);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}