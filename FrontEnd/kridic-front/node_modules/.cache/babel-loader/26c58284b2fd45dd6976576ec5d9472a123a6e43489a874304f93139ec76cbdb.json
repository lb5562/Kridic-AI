{"ast":null,"code":"import * as uuid from \"uuid\";\nimport { AsyncCaller } from \"./utils/async_caller.js\";\nimport { convertLangChainMessageToExample, isLangChainMessage } from \"./utils/messages.js\";\nimport { getEnvironmentVariable, getLangChainEnvVarsMetadata, getRuntimeEnvironment } from \"./utils/env.js\";\nimport { __version__ } from \"./index.js\";\nimport { assertUuid } from \"./utils/_uuid.js\";\nasync function mergeRuntimeEnvIntoRunCreates(runs) {\n  const runtimeEnv = await getRuntimeEnvironment();\n  const envVars = getLangChainEnvVarsMetadata();\n  return runs.map(run => {\n    const extra = run.extra ?? {};\n    const metadata = extra.metadata;\n    run.extra = {\n      ...extra,\n      runtime: {\n        ...runtimeEnv,\n        ...extra?.runtime\n      },\n      metadata: {\n        ...envVars,\n        ...(envVars.revision_id || run.revision_id ? {\n          revision_id: run.revision_id ?? envVars.revision_id\n        } : {}),\n        ...metadata\n      }\n    };\n    return run;\n  });\n}\nconst getTracingSamplingRate = () => {\n  const samplingRateStr = getEnvironmentVariable(\"LANGCHAIN_TRACING_SAMPLING_RATE\");\n  if (samplingRateStr === undefined) {\n    return undefined;\n  }\n  const samplingRate = parseFloat(samplingRateStr);\n  if (samplingRate < 0 || samplingRate > 1) {\n    throw new Error(`LANGCHAIN_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n  }\n  return samplingRate;\n};\n// utility functions\nconst isLocalhost = url => {\n  const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n  const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n  return hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\";\n};\nconst raiseForStatus = async (response, operation) => {\n  // consume the response body to release the connection\n  // https://undici.nodejs.org/#/?id=garbage-collection\n  const body = await response.text();\n  if (!response.ok) {\n    throw new Error(`Failed to ${operation}: ${response.status} ${response.statusText} ${body}`);\n  }\n};\nasync function toArray(iterable) {\n  const result = [];\n  for await (const item of iterable) {\n    result.push(item);\n  }\n  return result;\n}\nfunction trimQuotes(str) {\n  if (str === undefined) {\n    return undefined;\n  }\n  return str.trim().replace(/^\"(.*)\"$/, \"$1\").replace(/^'(.*)'$/, \"$1\");\n}\nconst handle429 = async response => {\n  if (response?.status === 429) {\n    const retryAfter = parseInt(response.headers.get(\"retry-after\") ?? \"30\", 10) * 1000;\n    if (retryAfter > 0) {\n      await new Promise(resolve => setTimeout(resolve, retryAfter));\n      // Return directly after calling this check\n      return true;\n    }\n  }\n  // Fall back to existing status checks\n  return false;\n};\nexport class Queue {\n  constructor() {\n    Object.defineProperty(this, \"items\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n  }\n  get size() {\n    return this.items.length;\n  }\n  push(item) {\n    // this.items.push is synchronous with promise creation:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\n    return new Promise(resolve => {\n      this.items.push([item, resolve]);\n    });\n  }\n  pop(upToN) {\n    if (upToN < 1) {\n      throw new Error(\"Number of items to pop off may not be less than 1.\");\n    }\n    const popped = [];\n    while (popped.length < upToN && this.items.length) {\n      const item = this.items.shift();\n      if (item) {\n        popped.push(item);\n      } else {\n        break;\n      }\n    }\n    return [popped.map(it => it[0]), () => popped.forEach(it => it[1]())];\n  }\n}\n// 20 MB\nexport const DEFAULT_BATCH_SIZE_LIMIT_BYTES = 20_971_520;\nexport class Client {\n  constructor(config = {}) {\n    Object.defineProperty(this, \"apiKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"apiUrl\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"webUrl\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"caller\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"batchIngestCaller\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"timeout_ms\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_tenantId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, \"hideInputs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"hideOutputs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"tracingSampleRate\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"sampledPostUuids\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Set()\n    });\n    Object.defineProperty(this, \"autoBatchTracing\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"batchEndpointSupported\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"autoBatchQueue\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Queue()\n    });\n    Object.defineProperty(this, \"pendingAutoBatchedRunLimit\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 100\n    });\n    Object.defineProperty(this, \"autoBatchTimeout\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"autoBatchInitialDelayMs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 250\n    });\n    Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 50\n    });\n    Object.defineProperty(this, \"serverInfo\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fetchOptions\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    const defaultConfig = Client.getDefaultClientConfig();\n    this.tracingSampleRate = getTracingSamplingRate();\n    this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n    this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n    this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n    this.timeout_ms = config.timeout_ms ?? 12_000;\n    this.caller = new AsyncCaller(config.callerOptions ?? {});\n    this.batchIngestCaller = new AsyncCaller({\n      ...(config.callerOptions ?? {}),\n      onFailedResponseHook: handle429\n    });\n    this.hideInputs = config.hideInputs ?? defaultConfig.hideInputs;\n    this.hideOutputs = config.hideOutputs ?? defaultConfig.hideOutputs;\n    this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n    this.pendingAutoBatchedRunLimit = config.pendingAutoBatchedRunLimit ?? this.pendingAutoBatchedRunLimit;\n    this.fetchOptions = config.fetchOptions || {};\n  }\n  static getDefaultClientConfig() {\n    const apiKey = getEnvironmentVariable(\"LANGCHAIN_API_KEY\");\n    const apiUrl = getEnvironmentVariable(\"LANGCHAIN_ENDPOINT\") ?? \"https://api.smith.langchain.com\";\n    const hideInputs = getEnvironmentVariable(\"LANGCHAIN_HIDE_INPUTS\") === \"true\";\n    const hideOutputs = getEnvironmentVariable(\"LANGCHAIN_HIDE_OUTPUTS\") === \"true\";\n    return {\n      apiUrl: apiUrl,\n      apiKey: apiKey,\n      webUrl: undefined,\n      hideInputs: hideInputs,\n      hideOutputs: hideOutputs\n    };\n  }\n  getHostUrl() {\n    if (this.webUrl) {\n      return this.webUrl;\n    } else if (isLocalhost(this.apiUrl)) {\n      this.webUrl = \"http://localhost:3000\";\n      return this.webUrl;\n    } else if (this.apiUrl.includes(\"/api\") && !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n      this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n      return this.webUrl;\n    } else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n      this.webUrl = \"https://dev.smith.langchain.com\";\n      return this.webUrl;\n    } else {\n      this.webUrl = \"https://smith.langchain.com\";\n      return this.webUrl;\n    }\n  }\n  get headers() {\n    const headers = {\n      \"User-Agent\": `langsmith-js/${__version__}`\n    };\n    if (this.apiKey) {\n      headers[\"x-api-key\"] = `${this.apiKey}`;\n    }\n    return headers;\n  }\n  processInputs(inputs) {\n    if (this.hideInputs === false) {\n      return inputs;\n    }\n    if (this.hideInputs === true) {\n      return {};\n    }\n    if (typeof this.hideInputs === \"function\") {\n      return this.hideInputs(inputs);\n    }\n    return inputs;\n  }\n  processOutputs(outputs) {\n    if (this.hideOutputs === false) {\n      return outputs;\n    }\n    if (this.hideOutputs === true) {\n      return {};\n    }\n    if (typeof this.hideOutputs === \"function\") {\n      return this.hideOutputs(outputs);\n    }\n    return outputs;\n  }\n  prepareRunCreateOrUpdateInputs(run) {\n    const runParams = {\n      ...run\n    };\n    if (runParams.inputs !== undefined) {\n      runParams.inputs = this.processInputs(runParams.inputs);\n    }\n    if (runParams.outputs !== undefined) {\n      runParams.outputs = this.processOutputs(runParams.outputs);\n    }\n    return runParams;\n  }\n  async _getResponse(path, queryParams) {\n    const paramsString = queryParams?.toString() ?? \"\";\n    const url = `${this.apiUrl}${path}?${paramsString}`;\n    const response = await this.caller.call(fetch, url, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n    }\n    return response;\n  }\n  async _get(path, queryParams) {\n    const response = await this._getResponse(path, queryParams);\n    return response.json();\n  }\n  async *_getPaginated(path, queryParams = new URLSearchParams()) {\n    let offset = Number(queryParams.get(\"offset\")) || 0;\n    const limit = Number(queryParams.get(\"limit\")) || 100;\n    while (true) {\n      queryParams.set(\"offset\", String(offset));\n      queryParams.set(\"limit\", String(limit));\n      const url = `${this.apiUrl}${path}?${queryParams}`;\n      const response = await this.caller.call(fetch, url, {\n        method: \"GET\",\n        headers: this.headers,\n        signal: AbortSignal.timeout(this.timeout_ms),\n        ...this.fetchOptions\n      });\n      if (!response.ok) {\n        throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n      }\n      const items = await response.json();\n      if (items.length === 0) {\n        break;\n      }\n      yield items;\n      if (items.length < limit) {\n        break;\n      }\n      offset += items.length;\n    }\n  }\n  async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n    const bodyParams = body ? {\n      ...body\n    } : {};\n    while (true) {\n      const response = await this.caller.call(fetch, `${this.apiUrl}${path}`, {\n        method: requestMethod,\n        headers: {\n          ...this.headers,\n          \"Content-Type\": \"application/json\"\n        },\n        signal: AbortSignal.timeout(this.timeout_ms),\n        ...this.fetchOptions,\n        body: JSON.stringify(bodyParams)\n      });\n      const responseBody = await response.json();\n      if (!responseBody) {\n        break;\n      }\n      if (!responseBody[dataKey]) {\n        break;\n      }\n      yield responseBody[dataKey];\n      const cursors = responseBody.cursors;\n      if (!cursors) {\n        break;\n      }\n      if (!cursors.next) {\n        break;\n      }\n      bodyParams.cursor = cursors.next;\n    }\n  }\n  _filterForSampling(runs, patch = false) {\n    if (this.tracingSampleRate === undefined) {\n      return runs;\n    }\n    if (patch) {\n      const sampled = [];\n      for (const run of runs) {\n        if (this.sampledPostUuids.has(run.id)) {\n          sampled.push(run);\n          this.sampledPostUuids.delete(run.id);\n        }\n      }\n      return sampled;\n    } else {\n      const sampled = [];\n      for (const run of runs) {\n        if (Math.random() < this.tracingSampleRate) {\n          sampled.push(run);\n          this.sampledPostUuids.add(run.id);\n        }\n      }\n      return sampled;\n    }\n  }\n  async drainAutoBatchQueue() {\n    while (this.autoBatchQueue.size >= 0) {\n      const [batch, done] = this.autoBatchQueue.pop(this.pendingAutoBatchedRunLimit);\n      if (!batch.length) {\n        done();\n        return;\n      }\n      try {\n        await this.batchIngestRuns({\n          runCreates: batch.filter(item => item.action === \"create\").map(item => item.item),\n          runUpdates: batch.filter(item => item.action === \"update\").map(item => item.item)\n        });\n      } finally {\n        done();\n      }\n    }\n  }\n  async processRunOperation(item, immediatelyTriggerBatch) {\n    const oldTimeout = this.autoBatchTimeout;\n    clearTimeout(this.autoBatchTimeout);\n    this.autoBatchTimeout = undefined;\n    const itemPromise = this.autoBatchQueue.push(item);\n    if (immediatelyTriggerBatch || this.autoBatchQueue.size > this.pendingAutoBatchedRunLimit) {\n      await this.drainAutoBatchQueue();\n    }\n    if (this.autoBatchQueue.size > 0) {\n      this.autoBatchTimeout = setTimeout(() => {\n        this.autoBatchTimeout = undefined;\n        // This error would happen in the background and is uncatchable\n        // from the outside. So just log instead.\n        void this.drainAutoBatchQueue().catch(console.error);\n      }, oldTimeout ? this.autoBatchAggregationDelayMs : this.autoBatchInitialDelayMs);\n    }\n    return itemPromise;\n  }\n  async _getServerInfo() {\n    const response = await fetch(`${this.apiUrl}/info`, {\n      method: \"GET\",\n      headers: {\n        Accept: \"application/json\"\n      },\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    if (!response.ok) {\n      // consume the response body to release the connection\n      // https://undici.nodejs.org/#/?id=garbage-collection\n      await response.text();\n      throw new Error(\"Failed to retrieve server info.\");\n    }\n    return response.json();\n  }\n  async batchEndpointIsSupported() {\n    try {\n      this.serverInfo = await this._getServerInfo();\n    } catch (e) {\n      return false;\n    }\n    return true;\n  }\n  async createRun(run) {\n    if (!this._filterForSampling([run]).length) {\n      return;\n    }\n    const headers = {\n      ...this.headers,\n      \"Content-Type\": \"application/json\"\n    };\n    const session_name = run.project_name;\n    delete run.project_name;\n    const runCreate = this.prepareRunCreateOrUpdateInputs({\n      session_name,\n      ...run,\n      start_time: run.start_time ?? Date.now()\n    });\n    if (this.autoBatchTracing && runCreate.trace_id !== undefined && runCreate.dotted_order !== undefined) {\n      void this.processRunOperation({\n        action: \"create\",\n        item: runCreate\n      }).catch(console.error);\n      return;\n    }\n    const mergedRunCreateParams = await mergeRuntimeEnvIntoRunCreates([runCreate]);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs`, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(mergedRunCreateParams[0]),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"create run\");\n  }\n  /**\n   * Batch ingest/upsert multiple runs in the Langsmith system.\n   * @param runs\n   */\n  async batchIngestRuns({\n    runCreates,\n    runUpdates\n  }) {\n    if (runCreates === undefined && runUpdates === undefined) {\n      return;\n    }\n    let preparedCreateParams = runCreates?.map(create => this.prepareRunCreateOrUpdateInputs(create)) ?? [];\n    let preparedUpdateParams = runUpdates?.map(update => this.prepareRunCreateOrUpdateInputs(update)) ?? [];\n    if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n      const createById = preparedCreateParams.reduce((params, run) => {\n        if (!run.id) {\n          return params;\n        }\n        params[run.id] = run;\n        return params;\n      }, {});\n      const standaloneUpdates = [];\n      for (const updateParam of preparedUpdateParams) {\n        if (updateParam.id !== undefined && createById[updateParam.id]) {\n          createById[updateParam.id] = {\n            ...createById[updateParam.id],\n            ...updateParam\n          };\n        } else {\n          standaloneUpdates.push(updateParam);\n        }\n      }\n      preparedCreateParams = Object.values(createById);\n      preparedUpdateParams = standaloneUpdates;\n    }\n    const rawBatch = {\n      post: this._filterForSampling(preparedCreateParams),\n      patch: this._filterForSampling(preparedUpdateParams, true)\n    };\n    if (!rawBatch.post.length && !rawBatch.patch.length) {\n      return;\n    }\n    preparedCreateParams = await mergeRuntimeEnvIntoRunCreates(preparedCreateParams);\n    if (this.batchEndpointSupported === undefined) {\n      this.batchEndpointSupported = await this.batchEndpointIsSupported();\n    }\n    if (!this.batchEndpointSupported) {\n      this.autoBatchTracing = false;\n      for (const preparedCreateParam of rawBatch.post) {\n        await this.createRun(preparedCreateParam);\n      }\n      for (const preparedUpdateParam of rawBatch.patch) {\n        if (preparedUpdateParam.id !== undefined) {\n          await this.updateRun(preparedUpdateParam.id, preparedUpdateParam);\n        }\n      }\n      return;\n    }\n    const sizeLimitBytes = this.serverInfo?.batch_ingest_config?.size_limit_bytes ?? DEFAULT_BATCH_SIZE_LIMIT_BYTES;\n    const batchChunks = {\n      post: [],\n      patch: []\n    };\n    let currentBatchSizeBytes = 0;\n    for (const k of [\"post\", \"patch\"]) {\n      const key = k;\n      const batchItems = rawBatch[key].reverse();\n      let batchItem = batchItems.pop();\n      while (batchItem !== undefined) {\n        const stringifiedBatchItem = JSON.stringify(batchItem);\n        if (currentBatchSizeBytes > 0 && currentBatchSizeBytes + stringifiedBatchItem.length > sizeLimitBytes) {\n          await this._postBatchIngestRuns(JSON.stringify(batchChunks));\n          currentBatchSizeBytes = 0;\n          batchChunks.post = [];\n          batchChunks.patch = [];\n        }\n        currentBatchSizeBytes += stringifiedBatchItem.length;\n        batchChunks[key].push(batchItem);\n        batchItem = batchItems.pop();\n      }\n    }\n    if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {\n      await this._postBatchIngestRuns(JSON.stringify(batchChunks));\n    }\n  }\n  async _postBatchIngestRuns(body) {\n    const headers = {\n      ...this.headers,\n      \"Content-Type\": \"application/json\",\n      Accept: \"application/json\"\n    };\n    const response = await this.batchIngestCaller.call(fetch, `${this.apiUrl}/runs/batch`, {\n      method: \"POST\",\n      headers,\n      body: body,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"batch create run\");\n  }\n  async updateRun(runId, run) {\n    assertUuid(runId);\n    if (run.inputs) {\n      run.inputs = this.processInputs(run.inputs);\n    }\n    if (run.outputs) {\n      run.outputs = this.processOutputs(run.outputs);\n    }\n    // TODO: Untangle types\n    const data = {\n      ...run,\n      id: runId\n    };\n    if (!this._filterForSampling([data], true).length) {\n      return;\n    }\n    if (this.autoBatchTracing && data.trace_id !== undefined && data.dotted_order !== undefined) {\n      if (run.end_time !== undefined && data.parent_run_id === undefined) {\n        // Trigger a batch as soon as a root trace ends and block to ensure trace finishes\n        // in serverless environments.\n        await this.processRunOperation({\n          action: \"update\",\n          item: data\n        }, true);\n        return;\n      } else {\n        void this.processRunOperation({\n          action: \"update\",\n          item: data\n        }).catch(console.error);\n      }\n      return;\n    }\n    const headers = {\n      ...this.headers,\n      \"Content-Type\": \"application/json\"\n    };\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}`, {\n      method: \"PATCH\",\n      headers,\n      body: JSON.stringify(run),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"update run\");\n  }\n  async readRun(runId, {\n    loadChildRuns\n  } = {\n    loadChildRuns: false\n  }) {\n    assertUuid(runId);\n    let run = await this._get(`/runs/${runId}`);\n    if (loadChildRuns && run.child_run_ids) {\n      run = await this._loadChildRuns(run);\n    }\n    return run;\n  }\n  async getRunUrl({\n    runId,\n    run,\n    projectOpts\n  }) {\n    if (run !== undefined) {\n      let sessionId;\n      if (run.session_id) {\n        sessionId = run.session_id;\n      } else if (projectOpts?.projectName) {\n        sessionId = (await this.readProject({\n          projectName: projectOpts?.projectName\n        })).id;\n      } else if (projectOpts?.projectId) {\n        sessionId = projectOpts?.projectId;\n      } else {\n        const project = await this.readProject({\n          projectName: getEnvironmentVariable(\"LANGCHAIN_PROJECT\") || \"default\"\n        });\n        sessionId = project.id;\n      }\n      const tenantId = await this._getTenantId();\n      return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n    } else if (runId !== undefined) {\n      const run_ = await this.readRun(runId);\n      if (!run_.app_path) {\n        throw new Error(`Run ${runId} has no app_path`);\n      }\n      const baseUrl = this.getHostUrl();\n      return `${baseUrl}${run_.app_path}`;\n    } else {\n      throw new Error(\"Must provide either runId or run\");\n    }\n  }\n  async _loadChildRuns(run) {\n    const childRuns = await toArray(this.listRuns({\n      id: run.child_run_ids\n    }));\n    const treemap = {};\n    const runs = {};\n    // TODO: make dotted order required when the migration finishes\n    childRuns.sort((a, b) => (a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n    for (const childRun of childRuns) {\n      if (childRun.parent_run_id === null || childRun.parent_run_id === undefined) {\n        throw new Error(`Child run ${childRun.id} has no parent`);\n      }\n      if (!(childRun.parent_run_id in treemap)) {\n        treemap[childRun.parent_run_id] = [];\n      }\n      treemap[childRun.parent_run_id].push(childRun);\n      runs[childRun.id] = childRun;\n    }\n    run.child_runs = treemap[run.id] || [];\n    for (const runId in treemap) {\n      if (runId !== run.id) {\n        runs[runId].child_runs = treemap[runId];\n      }\n    }\n    return run;\n  }\n  /**\n   * List runs from the LangSmith server.\n   * @param projectId - The ID of the project to filter by.\n   * @param projectName - The name of the project to filter by.\n   * @param parentRunId - The ID of the parent run to filter by.\n   * @param traceId - The ID of the trace to filter by.\n   * @param referenceExampleId - The ID of the reference example to filter by.\n   * @param startTime - The start time to filter by.\n   * @param isRoot - Indicates whether to only return root runs.\n   * @param runType - The run type to filter by.\n   * @param error - Indicates whether to filter by error runs.\n   * @param id - The ID of the run to filter by.\n   * @param query - The query string to filter by.\n   * @param filter - The filter string to apply to the run spans.\n   * @param traceFilter - The filter string to apply on the root run of the trace.\n   * @param limit - The maximum number of runs to retrieve.\n   * @returns {AsyncIterable<Run>} - The runs.\n   *\n   * @example\n   * // List all runs in a project\n   * const projectRuns = client.listRuns({ projectName: \"<your_project>\" });\n   *\n   * @example\n   * // List LLM and Chat runs in the last 24 hours\n   * const todaysLLMRuns = client.listRuns({\n   *   projectName: \"<your_project>\",\n   *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),\n   *   run_type: \"llm\",\n   * });\n   *\n   * @example\n   * // List traces in a project\n   * const rootRuns = client.listRuns({\n   *   projectName: \"<your_project>\",\n   *   execution_order: 1,\n   * });\n   *\n   * @example\n   * // List runs without errors\n   * const correctRuns = client.listRuns({\n   *   projectName: \"<your_project>\",\n   *   error: false,\n   * });\n   *\n   * @example\n   * // List runs by run ID\n   * const runIds = [\n   *   \"a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836\",\n   *   \"9398e6be-964f-4aa4-8ae9-ad78cd4b7074\",\n   * ];\n   * const selectedRuns = client.listRuns({ run_ids: runIds });\n   *\n   * @example\n   * // List all \"chain\" type runs that took more than 10 seconds and had `total_tokens` greater than 5000\n   * const chainRuns = client.listRuns({\n   *   projectName: \"<your_project>\",\n   *   filter: 'and(eq(run_type, \"chain\"), gt(latency, 10), gt(total_tokens, 5000))',\n   * });\n   *\n   * @example\n   * // List all runs called \"extractor\" whose root of the trace was assigned feedback \"user_score\" score of 1\n   * const goodExtractorRuns = client.listRuns({\n   *   projectName: \"<your_project>\",\n   *   filter: 'eq(name, \"extractor\")',\n   *   traceFilter: 'and(eq(feedback_key, \"user_score\"), eq(feedback_score, 1))',\n   * });\n   *\n   * @example\n   * // List all runs that started after a specific timestamp and either have \"error\" not equal to null or a \"Correctness\" feedback score equal to 0\n   * const complexRuns = client.listRuns({\n   *   projectName: \"<your_project>\",\n   *   filter: 'and(gt(start_time, \"2023-07-15T12:34:56Z\"), or(neq(error, null), and(eq(feedback_key, \"Correctness\"), eq(feedback_score, 0.0))))',\n   * });\n   *\n   * @example\n   * // List all runs where `tags` include \"experimental\" or \"beta\" and `latency` is greater than 2 seconds\n   * const taggedRuns = client.listRuns({\n   *   projectName: \"<your_project>\",\n   *   filter: 'and(or(has(tags, \"experimental\"), has(tags, \"beta\")), gt(latency, 2))',\n   * });\n   */\n  async *listRuns(props) {\n    const {\n      projectId,\n      projectName,\n      parentRunId,\n      traceId,\n      referenceExampleId,\n      startTime,\n      executionOrder,\n      isRoot,\n      runType,\n      error,\n      id,\n      query,\n      filter,\n      traceFilter,\n      treeFilter,\n      limit,\n      select\n    } = props;\n    let projectIds = [];\n    if (projectId) {\n      projectIds = Array.isArray(projectId) ? projectId : [projectId];\n    }\n    if (projectName) {\n      const projectNames = Array.isArray(projectName) ? projectName : [projectName];\n      const projectIds_ = await Promise.all(projectNames.map(name => this.readProject({\n        projectName: name\n      }).then(project => project.id)));\n      projectIds.push(...projectIds_);\n    }\n    const default_select = [\"app_path\", \"child_run_ids\", \"completion_cost\", \"completion_tokens\", \"dotted_order\", \"end_time\", \"error\", \"events\", \"extra\", \"feedback_stats\", \"first_token_time\", \"id\", \"inputs\", \"name\", \"outputs\", \"parent_run_id\", \"parent_run_ids\", \"prompt_cost\", \"prompt_tokens\", \"reference_example_id\", \"run_type\", \"session_id\", \"start_time\", \"status\", \"tags\", \"total_cost\", \"total_tokens\", \"trace_id\"];\n    const body = {\n      session: projectIds.length ? projectIds : null,\n      run_type: runType,\n      reference_example: referenceExampleId,\n      query,\n      filter,\n      trace_filter: traceFilter,\n      tree_filter: treeFilter,\n      execution_order: executionOrder,\n      parent_run: parentRunId,\n      start_time: startTime ? startTime.toISOString() : null,\n      error,\n      id,\n      limit,\n      trace: traceId,\n      select: select ? select : default_select,\n      is_root: isRoot\n    };\n    let runsYielded = 0;\n    for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)) {\n      if (limit) {\n        if (runsYielded >= limit) {\n          break;\n        }\n        if (runs.length + runsYielded > limit) {\n          const newRuns = runs.slice(0, limit - runsYielded);\n          yield* newRuns;\n          break;\n        }\n        runsYielded += runs.length;\n        yield* runs;\n      } else {\n        yield* runs;\n      }\n    }\n  }\n  async shareRun(runId, {\n    shareId\n  } = {}) {\n    const data = {\n      run_id: runId,\n      share_token: shareId || uuid.v4()\n    };\n    assertUuid(runId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n      method: \"PUT\",\n      headers: this.headers,\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    const result = await response.json();\n    if (result === null || !(\"share_token\" in result)) {\n      throw new Error(\"Invalid response from server\");\n    }\n    return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n  }\n  async unshareRun(runId) {\n    assertUuid(runId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"unshare run\");\n  }\n  async readRunSharedLink(runId) {\n    assertUuid(runId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    const result = await response.json();\n    if (result === null || !(\"share_token\" in result)) {\n      return undefined;\n    }\n    return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n  }\n  async listSharedRuns(shareToken, {\n    runIds\n  } = {}) {\n    const queryParams = new URLSearchParams({\n      share_token: shareToken\n    });\n    if (runIds !== undefined) {\n      for (const runId of runIds) {\n        queryParams.append(\"id\", runId);\n      }\n    }\n    assertUuid(shareToken);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    const runs = await response.json();\n    return runs;\n  }\n  async readDatasetSharedSchema(datasetId, datasetName) {\n    if (!datasetId && !datasetName) {\n      throw new Error(\"Either datasetId or datasetName must be given\");\n    }\n    if (!datasetId) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId = dataset.id;\n    }\n    assertUuid(datasetId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    const shareSchema = await response.json();\n    shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n    return shareSchema;\n  }\n  async shareDataset(datasetId, datasetName) {\n    if (!datasetId && !datasetName) {\n      throw new Error(\"Either datasetId or datasetName must be given\");\n    }\n    if (!datasetId) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId = dataset.id;\n    }\n    const data = {\n      dataset_id: datasetId\n    };\n    assertUuid(datasetId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n      method: \"PUT\",\n      headers: this.headers,\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    const shareSchema = await response.json();\n    shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n    return shareSchema;\n  }\n  async unshareDataset(datasetId) {\n    assertUuid(datasetId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"unshare dataset\");\n  }\n  async readSharedDataset(shareToken) {\n    assertUuid(shareToken);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/datasets`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    const dataset = await response.json();\n    return dataset;\n  }\n  async createProject({\n    projectName,\n    description = null,\n    metadata = null,\n    upsert = false,\n    projectExtra = null,\n    referenceDatasetId = null\n  }) {\n    const upsert_ = upsert ? `?upsert=true` : \"\";\n    const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n    const extra = projectExtra || {};\n    if (metadata) {\n      extra[\"metadata\"] = metadata;\n    }\n    const body = {\n      name: projectName,\n      extra,\n      description\n    };\n    if (referenceDatasetId !== null) {\n      body[\"reference_dataset_id\"] = referenceDatasetId;\n    }\n    const response = await this.caller.call(fetch, endpoint, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    const result = await response.json();\n    if (!response.ok) {\n      throw new Error(`Failed to create session ${projectName}: ${response.status} ${response.statusText}`);\n    }\n    return result;\n  }\n  async updateProject(projectId, {\n    name = null,\n    description = null,\n    metadata = null,\n    projectExtra = null,\n    endTime = null\n  }) {\n    const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n    let extra = projectExtra;\n    if (metadata) {\n      extra = {\n        ...(extra || {}),\n        metadata\n      };\n    }\n    const body = {\n      name,\n      extra,\n      description,\n      end_time: endTime ? new Date(endTime).toISOString() : null\n    };\n    const response = await this.caller.call(fetch, endpoint, {\n      method: \"PATCH\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    const result = await response.json();\n    if (!response.ok) {\n      throw new Error(`Failed to update project ${projectId}: ${response.status} ${response.statusText}`);\n    }\n    return result;\n  }\n  async hasProject({\n    projectId,\n    projectName\n  }) {\n    // TODO: Add a head request\n    let path = \"/sessions\";\n    const params = new URLSearchParams();\n    if (projectId !== undefined && projectName !== undefined) {\n      throw new Error(\"Must provide either projectName or projectId, not both\");\n    } else if (projectId !== undefined) {\n      assertUuid(projectId);\n      path += `/${projectId}`;\n    } else if (projectName !== undefined) {\n      params.append(\"name\", projectName);\n    } else {\n      throw new Error(\"Must provide projectName or projectId\");\n    }\n    const response = await this.caller.call(fetch, `${this.apiUrl}${path}?${params}`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    // consume the response body to release the connection\n    // https://undici.nodejs.org/#/?id=garbage-collection\n    try {\n      const result = await response.json();\n      if (!response.ok) {\n        return false;\n      }\n      // If it's OK and we're querying by name, need to check the list is not empty\n      if (Array.isArray(result)) {\n        return result.length > 0;\n      }\n      // projectId querying\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  async readProject({\n    projectId,\n    projectName,\n    includeStats\n  }) {\n    let path = \"/sessions\";\n    const params = new URLSearchParams();\n    if (projectId !== undefined && projectName !== undefined) {\n      throw new Error(\"Must provide either projectName or projectId, not both\");\n    } else if (projectId !== undefined) {\n      assertUuid(projectId);\n      path += `/${projectId}`;\n    } else if (projectName !== undefined) {\n      params.append(\"name\", projectName);\n    } else {\n      throw new Error(\"Must provide projectName or projectId\");\n    }\n    if (includeStats !== undefined) {\n      params.append(\"include_stats\", includeStats.toString());\n    }\n    const response = await this._get(path, params);\n    let result;\n    if (Array.isArray(response)) {\n      if (response.length === 0) {\n        throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n      }\n      result = response[0];\n    } else {\n      result = response;\n    }\n    return result;\n  }\n  async getProjectUrl({\n    projectId,\n    projectName\n  }) {\n    if (projectId === undefined && projectName === undefined) {\n      throw new Error(\"Must provide either projectName or projectId\");\n    }\n    const project = await this.readProject({\n      projectId,\n      projectName\n    });\n    const tenantId = await this._getTenantId();\n    return `${this.getHostUrl()}/o/${tenantId}/projects/p/${project.id}`;\n  }\n  async getDatasetUrl({\n    datasetId,\n    datasetName\n  }) {\n    if (datasetId === undefined && datasetName === undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId\");\n    }\n    const dataset = await this.readDataset({\n      datasetId,\n      datasetName\n    });\n    const tenantId = await this._getTenantId();\n    return `${this.getHostUrl()}/o/${tenantId}/datasets/${dataset.id}`;\n  }\n  async _getTenantId() {\n    if (this._tenantId !== null) {\n      return this._tenantId;\n    }\n    const queryParams = new URLSearchParams({\n      limit: \"1\"\n    });\n    for await (const projects of this._getPaginated(\"/sessions\", queryParams)) {\n      this._tenantId = projects[0].tenant_id;\n      return projects[0].tenant_id;\n    }\n    throw new Error(\"No projects found to resolve tenant.\");\n  }\n  async *listProjects({\n    projectIds,\n    name,\n    nameContains,\n    referenceDatasetId,\n    referenceDatasetName,\n    referenceFree\n  } = {}) {\n    const params = new URLSearchParams();\n    if (projectIds !== undefined) {\n      for (const projectId of projectIds) {\n        params.append(\"id\", projectId);\n      }\n    }\n    if (name !== undefined) {\n      params.append(\"name\", name);\n    }\n    if (nameContains !== undefined) {\n      params.append(\"name_contains\", nameContains);\n    }\n    if (referenceDatasetId !== undefined) {\n      params.append(\"reference_dataset\", referenceDatasetId);\n    } else if (referenceDatasetName !== undefined) {\n      const dataset = await this.readDataset({\n        datasetName: referenceDatasetName\n      });\n      params.append(\"reference_dataset\", dataset.id);\n    }\n    if (referenceFree !== undefined) {\n      params.append(\"reference_free\", referenceFree.toString());\n    }\n    for await (const projects of this._getPaginated(\"/sessions\", params)) {\n      yield* projects;\n    }\n  }\n  async deleteProject({\n    projectId,\n    projectName\n  }) {\n    let projectId_;\n    if (projectId === undefined && projectName === undefined) {\n      throw new Error(\"Must provide projectName or projectId\");\n    } else if (projectId !== undefined && projectName !== undefined) {\n      throw new Error(\"Must provide either projectName or projectId, not both\");\n    } else if (projectId === undefined) {\n      projectId_ = (await this.readProject({\n        projectName\n      })).id;\n    } else {\n      projectId_ = projectId;\n    }\n    assertUuid(projectId_);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/sessions/${projectId_}`, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, `delete session ${projectId_} (${projectName})`);\n  }\n  async uploadCsv({\n    csvFile,\n    fileName,\n    inputKeys,\n    outputKeys,\n    description,\n    dataType,\n    name\n  }) {\n    const url = `${this.apiUrl}/datasets/upload`;\n    const formData = new FormData();\n    formData.append(\"file\", csvFile, fileName);\n    inputKeys.forEach(key => {\n      formData.append(\"input_keys\", key);\n    });\n    outputKeys.forEach(key => {\n      formData.append(\"output_keys\", key);\n    });\n    if (description) {\n      formData.append(\"description\", description);\n    }\n    if (dataType) {\n      formData.append(\"data_type\", dataType);\n    }\n    if (name) {\n      formData.append(\"name\", name);\n    }\n    const response = await this.caller.call(fetch, url, {\n      method: \"POST\",\n      headers: this.headers,\n      body: formData,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    if (!response.ok) {\n      const result = await response.json();\n      if (result.detail && result.detail.includes(\"already exists\")) {\n        throw new Error(`Dataset ${fileName} already exists`);\n      }\n      throw new Error(`Failed to upload CSV: ${response.status} ${response.statusText}`);\n    }\n    const result = await response.json();\n    return result;\n  }\n  async createDataset(name, {\n    description,\n    dataType\n  } = {}) {\n    const body = {\n      name,\n      description\n    };\n    if (dataType) {\n      body.data_type = dataType;\n    }\n    const response = await this.caller.call(fetch, `${this.apiUrl}/datasets`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    if (!response.ok) {\n      const result = await response.json();\n      if (result.detail && result.detail.includes(\"already exists\")) {\n        throw new Error(`Dataset ${name} already exists`);\n      }\n      throw new Error(`Failed to create dataset ${response.status} ${response.statusText}`);\n    }\n    const result = await response.json();\n    return result;\n  }\n  async readDataset({\n    datasetId,\n    datasetName\n  }) {\n    let path = \"/datasets\";\n    // limit to 1 result\n    const params = new URLSearchParams({\n      limit: \"1\"\n    });\n    if (datasetId !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId !== undefined) {\n      assertUuid(datasetId);\n      path += `/${datasetId}`;\n    } else if (datasetName !== undefined) {\n      params.append(\"name\", datasetName);\n    } else {\n      throw new Error(\"Must provide datasetName or datasetId\");\n    }\n    const response = await this._get(path, params);\n    let result;\n    if (Array.isArray(response)) {\n      if (response.length === 0) {\n        throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n      }\n      result = response[0];\n    } else {\n      result = response;\n    }\n    return result;\n  }\n  async hasDataset({\n    datasetId,\n    datasetName\n  }) {\n    try {\n      await this.readDataset({\n        datasetId,\n        datasetName\n      });\n      return true;\n    } catch (e) {\n      if (\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      e instanceof Error && e.message.toLocaleLowerCase().includes(\"not found\")) {\n        return false;\n      }\n      throw e;\n    }\n  }\n  async diffDatasetVersions({\n    datasetId,\n    datasetName,\n    fromVersion,\n    toVersion\n  }) {\n    let datasetId_ = datasetId;\n    if (datasetId_ === undefined && datasetName === undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId\");\n    } else if (datasetId_ !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId_ === undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    }\n    const urlParams = new URLSearchParams({\n      from_version: typeof fromVersion === \"string\" ? fromVersion : fromVersion.toISOString(),\n      to_version: typeof toVersion === \"string\" ? toVersion : toVersion.toISOString()\n    });\n    const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);\n    return response;\n  }\n  async readDatasetOpenaiFinetuning({\n    datasetId,\n    datasetName\n  }) {\n    const path = \"/datasets\";\n    if (datasetId !== undefined) {\n      // do nothing\n    } else if (datasetName !== undefined) {\n      datasetId = (await this.readDataset({\n        datasetName\n      })).id;\n    } else {\n      throw new Error(\"Must provide datasetName or datasetId\");\n    }\n    const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n    const datasetText = await response.text();\n    const dataset = datasetText.trim().split(\"\\n\").map(line => JSON.parse(line));\n    return dataset;\n  }\n  async *listDatasets({\n    limit = 100,\n    offset = 0,\n    datasetIds,\n    datasetName,\n    datasetNameContains\n  } = {}) {\n    const path = \"/datasets\";\n    const params = new URLSearchParams({\n      limit: limit.toString(),\n      offset: offset.toString()\n    });\n    if (datasetIds !== undefined) {\n      for (const id_ of datasetIds) {\n        params.append(\"id\", id_);\n      }\n    }\n    if (datasetName !== undefined) {\n      params.append(\"name\", datasetName);\n    }\n    if (datasetNameContains !== undefined) {\n      params.append(\"name_contains\", datasetNameContains);\n    }\n    for await (const datasets of this._getPaginated(path, params)) {\n      yield* datasets;\n    }\n  }\n  async deleteDataset({\n    datasetId,\n    datasetName\n  }) {\n    let path = \"/datasets\";\n    let datasetId_ = datasetId;\n    if (datasetId !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetName !== undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    }\n    if (datasetId_ !== undefined) {\n      assertUuid(datasetId_);\n      path += `/${datasetId_}`;\n    } else {\n      throw new Error(\"Must provide datasetName or datasetId\");\n    }\n    const response = await this.caller.call(fetch, this.apiUrl + path, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n    }\n    await response.json();\n  }\n  async createExample(inputs, outputs, {\n    datasetId,\n    datasetName,\n    createdAt,\n    exampleId,\n    metadata,\n    split\n  }) {\n    let datasetId_ = datasetId;\n    if (datasetId_ === undefined && datasetName === undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId\");\n    } else if (datasetId_ !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId_ === undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    }\n    const createdAt_ = createdAt || new Date();\n    const data = {\n      dataset_id: datasetId_,\n      inputs,\n      outputs,\n      created_at: createdAt_?.toISOString(),\n      id: exampleId,\n      metadata,\n      split\n    };\n    const response = await this.caller.call(fetch, `${this.apiUrl}/examples`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to create example: ${response.status} ${response.statusText}`);\n    }\n    const result = await response.json();\n    return result;\n  }\n  async createExamples(props) {\n    const {\n      inputs,\n      outputs,\n      metadata,\n      sourceRunIds,\n      exampleIds,\n      datasetId,\n      datasetName\n    } = props;\n    let datasetId_ = datasetId;\n    if (datasetId_ === undefined && datasetName === undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId\");\n    } else if (datasetId_ !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId_ === undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    }\n    const formattedExamples = inputs.map((input, idx) => {\n      return {\n        dataset_id: datasetId_,\n        inputs: input,\n        outputs: outputs ? outputs[idx] : undefined,\n        metadata: metadata ? metadata[idx] : undefined,\n        split: props.splits ? props.splits[idx] : undefined,\n        id: exampleIds ? exampleIds[idx] : undefined,\n        source_run_id: sourceRunIds ? sourceRunIds[idx] : undefined\n      };\n    });\n    const response = await this.caller.call(fetch, `${this.apiUrl}/examples/bulk`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(formattedExamples),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to create examples: ${response.status} ${response.statusText}`);\n    }\n    const result = await response.json();\n    return result;\n  }\n  async createLLMExample(input, generation, options) {\n    return this.createExample({\n      input\n    }, {\n      output: generation\n    }, options);\n  }\n  async createChatExample(input, generations, options) {\n    const finalInput = input.map(message => {\n      if (isLangChainMessage(message)) {\n        return convertLangChainMessageToExample(message);\n      }\n      return message;\n    });\n    const finalOutput = isLangChainMessage(generations) ? convertLangChainMessageToExample(generations) : generations;\n    return this.createExample({\n      input: finalInput\n    }, {\n      output: finalOutput\n    }, options);\n  }\n  async readExample(exampleId) {\n    assertUuid(exampleId);\n    const path = `/examples/${exampleId}`;\n    return await this._get(path);\n  }\n  async *listExamples({\n    datasetId,\n    datasetName,\n    exampleIds,\n    asOf,\n    splits,\n    inlineS3Urls,\n    metadata\n  } = {}) {\n    let datasetId_;\n    if (datasetId !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId !== undefined) {\n      datasetId_ = datasetId;\n    } else if (datasetName !== undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    } else {\n      throw new Error(\"Must provide a datasetName or datasetId\");\n    }\n    const params = new URLSearchParams({\n      dataset: datasetId_\n    });\n    const dataset_version = asOf ? typeof asOf === \"string\" ? asOf : asOf?.toISOString() : undefined;\n    if (dataset_version) {\n      params.append(\"as_of\", dataset_version);\n    }\n    const inlineS3Urls_ = inlineS3Urls ?? true;\n    params.append(\"inline_s3_urls\", inlineS3Urls_.toString());\n    if (exampleIds !== undefined) {\n      for (const id_ of exampleIds) {\n        params.append(\"id\", id_);\n      }\n    }\n    if (splits !== undefined) {\n      for (const split of splits) {\n        params.append(\"splits\", split);\n      }\n    }\n    if (metadata !== undefined) {\n      const serializedMetadata = JSON.stringify(metadata);\n      params.append(\"metadata\", serializedMetadata);\n    }\n    for await (const examples of this._getPaginated(\"/examples\", params)) {\n      yield* examples;\n    }\n  }\n  async deleteExample(exampleId) {\n    assertUuid(exampleId);\n    const path = `/examples/${exampleId}`;\n    const response = await this.caller.call(fetch, this.apiUrl + path, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n    }\n    await response.json();\n  }\n  async updateExample(exampleId, update) {\n    assertUuid(exampleId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/examples/${exampleId}`, {\n      method: \"PATCH\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(update),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to update example ${exampleId}: ${response.status} ${response.statusText}`);\n    }\n    const result = await response.json();\n    return result;\n  }\n  async evaluateRun(run, evaluator, {\n    sourceInfo,\n    loadChildRuns,\n    referenceExample\n  } = {\n    loadChildRuns: false\n  }) {\n    let run_;\n    if (typeof run === \"string\") {\n      run_ = await this.readRun(run, {\n        loadChildRuns\n      });\n    } else if (typeof run === \"object\" && \"id\" in run) {\n      run_ = run;\n    } else {\n      throw new Error(`Invalid run type: ${typeof run}`);\n    }\n    if (run_.reference_example_id !== null && run_.reference_example_id !== undefined) {\n      referenceExample = await this.readExample(run_.reference_example_id);\n    }\n    const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n    let sourceInfo_ = sourceInfo ?? {};\n    if (feedbackResult.evaluatorInfo) {\n      sourceInfo_ = {\n        ...sourceInfo_,\n        ...feedbackResult.evaluatorInfo\n      };\n    }\n    const runId = feedbackResult.targetRunId ?? run_.id;\n    return await this.createFeedback(runId, feedbackResult.key, {\n      score: feedbackResult?.score,\n      value: feedbackResult?.value,\n      comment: feedbackResult?.comment,\n      correction: feedbackResult?.correction,\n      sourceInfo: sourceInfo_,\n      feedbackSourceType: \"model\",\n      sourceRunId: feedbackResult?.sourceRunId\n    });\n  }\n  async createFeedback(runId, key, {\n    score,\n    value,\n    correction,\n    comment,\n    sourceInfo,\n    feedbackSourceType = \"api\",\n    sourceRunId,\n    feedbackId,\n    feedbackConfig,\n    projectId,\n    comparativeExperimentId\n  }) {\n    if (!runId && !projectId) {\n      throw new Error(\"One of runId or projectId must be provided\");\n    }\n    if (runId && projectId) {\n      throw new Error(\"Only one of runId or projectId can be provided\");\n    }\n    const feedback_source = {\n      type: feedbackSourceType ?? \"api\",\n      metadata: sourceInfo ?? {}\n    };\n    if (sourceRunId !== undefined && feedback_source?.metadata !== undefined && !feedback_source.metadata[\"__run\"]) {\n      feedback_source.metadata[\"__run\"] = {\n        run_id: sourceRunId\n      };\n    }\n    if (feedback_source?.metadata !== undefined && feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n      assertUuid(feedback_source.metadata[\"__run\"].run_id);\n    }\n    const feedback = {\n      id: feedbackId ?? uuid.v4(),\n      run_id: runId,\n      key,\n      score,\n      value,\n      correction,\n      comment,\n      feedback_source: feedback_source,\n      comparative_experiment_id: comparativeExperimentId,\n      feedbackConfig,\n      session_id: projectId\n    };\n    const url = `${this.apiUrl}/feedback`;\n    const response = await this.caller.call(fetch, url, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(feedback),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"create feedback\");\n    return feedback;\n  }\n  async updateFeedback(feedbackId, {\n    score,\n    value,\n    correction,\n    comment\n  }) {\n    const feedbackUpdate = {};\n    if (score !== undefined && score !== null) {\n      feedbackUpdate[\"score\"] = score;\n    }\n    if (value !== undefined && value !== null) {\n      feedbackUpdate[\"value\"] = value;\n    }\n    if (correction !== undefined && correction !== null) {\n      feedbackUpdate[\"correction\"] = correction;\n    }\n    if (comment !== undefined && comment !== null) {\n      feedbackUpdate[\"comment\"] = comment;\n    }\n    assertUuid(feedbackId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/feedback/${feedbackId}`, {\n      method: \"PATCH\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(feedbackUpdate),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"update feedback\");\n  }\n  async readFeedback(feedbackId) {\n    assertUuid(feedbackId);\n    const path = `/feedback/${feedbackId}`;\n    const response = await this._get(path);\n    return response;\n  }\n  async deleteFeedback(feedbackId) {\n    assertUuid(feedbackId);\n    const path = `/feedback/${feedbackId}`;\n    const response = await this.caller.call(fetch, this.apiUrl + path, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n    }\n    await response.json();\n  }\n  async *listFeedback({\n    runIds,\n    feedbackKeys,\n    feedbackSourceTypes\n  } = {}) {\n    const queryParams = new URLSearchParams();\n    if (runIds) {\n      queryParams.append(\"run\", runIds.join(\",\"));\n    }\n    if (feedbackKeys) {\n      for (const key of feedbackKeys) {\n        queryParams.append(\"key\", key);\n      }\n    }\n    if (feedbackSourceTypes) {\n      for (const type of feedbackSourceTypes) {\n        queryParams.append(\"source\", type);\n      }\n    }\n    for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)) {\n      yield* feedbacks;\n    }\n  }\n  /**\n   * Creates a presigned feedback token and URL.\n   *\n   * The token can be used to authorize feedback metrics without\n   * needing an API key. This is useful for giving browser-based\n   * applications the ability to submit feedback without needing\n   * to expose an API key.\n   *\n   * @param runId - The ID of the run.\n   * @param feedbackKey - The feedback key.\n   * @param options - Additional options for the token.\n   * @param options.expiration - The expiration time for the token.\n   *\n   * @returns A promise that resolves to a FeedbackIngestToken.\n   */\n  async createPresignedFeedbackToken(runId, feedbackKey, {\n    expiration,\n    feedbackConfig\n  } = {}) {\n    const body = {\n      run_id: runId,\n      feedback_key: feedbackKey,\n      feedback_config: feedbackConfig\n    };\n    if (expiration) {\n      if (typeof expiration === \"string\") {\n        body[\"expires_at\"] = expiration;\n      } else if (expiration?.hours || expiration?.minutes || expiration?.days) {\n        body[\"expires_in\"] = expiration;\n      }\n    } else {\n      body[\"expires_in\"] = {\n        hours: 3\n      };\n    }\n    const response = await this.caller.call(fetch, `${this.apiUrl}/feedback/tokens`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    const result = await response.json();\n    return result;\n  }\n  async createComparativeExperiment({\n    name,\n    experimentIds,\n    referenceDatasetId,\n    createdAt,\n    description,\n    metadata,\n    id\n  }) {\n    if (experimentIds.length === 0) {\n      throw new Error(\"At least one experiment is required\");\n    }\n    if (!referenceDatasetId) {\n      referenceDatasetId = (await this.readProject({\n        projectId: experimentIds[0]\n      })).reference_dataset_id;\n    }\n    if (!referenceDatasetId == null) {\n      throw new Error(\"A reference dataset is required\");\n    }\n    const body = {\n      id,\n      name,\n      experiment_ids: experimentIds,\n      reference_dataset_id: referenceDatasetId,\n      description,\n      created_at: (createdAt ?? new Date())?.toISOString(),\n      extra: {}\n    };\n    if (metadata) body.extra[\"metadata\"] = metadata;\n    const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/comparative`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    return await response.json();\n  }\n  /**\n   * Retrieves a list of presigned feedback tokens for a given run ID.\n   * @param runId The ID of the run.\n   * @returns An async iterable of FeedbackIngestToken objects.\n   */\n  async *listPresignedFeedbackTokens(runId) {\n    assertUuid(runId);\n    const params = new URLSearchParams({\n      run_id: runId\n    });\n    for await (const tokens of this._getPaginated(\"/feedback/tokens\", params)) {\n      yield* tokens;\n    }\n  }\n  _selectEvalResults(results) {\n    let results_;\n    if (\"results\" in results) {\n      results_ = results.results;\n    } else {\n      results_ = [results];\n    }\n    return results_;\n  }\n  async logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n    const results = this._selectEvalResults(evaluatorResponse);\n    for (const res of results) {\n      let sourceInfo_ = sourceInfo || {};\n      if (res.evaluatorInfo) {\n        sourceInfo_ = {\n          ...res.evaluatorInfo,\n          ...sourceInfo_\n        };\n      }\n      let runId_ = null;\n      if (res.targetRunId) {\n        runId_ = res.targetRunId;\n      } else if (run) {\n        runId_ = run.id;\n      }\n      await this.createFeedback(runId_, res.key, {\n        score: res.score,\n        value: res.value,\n        comment: res.comment,\n        correction: res.correction,\n        sourceInfo: sourceInfo_,\n        sourceRunId: res.sourceRunId,\n        feedbackConfig: res.feedbackConfig,\n        feedbackSourceType: \"model\"\n      });\n    }\n    return results;\n  }\n}","map":{"version":3,"names":["uuid","AsyncCaller","convertLangChainMessageToExample","isLangChainMessage","getEnvironmentVariable","getLangChainEnvVarsMetadata","getRuntimeEnvironment","__version__","assertUuid","mergeRuntimeEnvIntoRunCreates","runs","runtimeEnv","envVars","map","run","extra","metadata","runtime","revision_id","getTracingSamplingRate","samplingRateStr","undefined","samplingRate","parseFloat","Error","isLocalhost","url","strippedUrl","replace","hostname","split","raiseForStatus","response","operation","body","text","ok","status","statusText","toArray","iterable","result","item","push","trimQuotes","str","trim","handle429","retryAfter","parseInt","headers","get","Promise","resolve","setTimeout","Queue","constructor","Object","defineProperty","enumerable","configurable","writable","value","size","items","length","pop","upToN","popped","shift","it","forEach","DEFAULT_BATCH_SIZE_LIMIT_BYTES","Client","config","Set","defaultConfig","getDefaultClientConfig","tracingSampleRate","apiUrl","apiKey","webUrl","timeout_ms","caller","callerOptions","batchIngestCaller","onFailedResponseHook","hideInputs","hideOutputs","autoBatchTracing","pendingAutoBatchedRunLimit","fetchOptions","getHostUrl","includes","endsWith","processInputs","inputs","processOutputs","outputs","prepareRunCreateOrUpdateInputs","runParams","_getResponse","path","queryParams","paramsString","toString","call","fetch","method","signal","AbortSignal","timeout","_get","json","_getPaginated","URLSearchParams","offset","Number","limit","set","String","_getCursorPaginatedList","requestMethod","dataKey","bodyParams","JSON","stringify","responseBody","cursors","next","cursor","_filterForSampling","patch","sampled","sampledPostUuids","has","id","delete","Math","random","add","drainAutoBatchQueue","autoBatchQueue","batch","done","batchIngestRuns","runCreates","filter","action","runUpdates","processRunOperation","immediatelyTriggerBatch","oldTimeout","autoBatchTimeout","clearTimeout","itemPromise","catch","console","error","autoBatchAggregationDelayMs","autoBatchInitialDelayMs","_getServerInfo","Accept","batchEndpointIsSupported","serverInfo","e","createRun","session_name","project_name","runCreate","start_time","Date","now","trace_id","dotted_order","mergedRunCreateParams","preparedCreateParams","create","preparedUpdateParams","update","createById","reduce","params","standaloneUpdates","updateParam","values","rawBatch","post","batchEndpointSupported","preparedCreateParam","preparedUpdateParam","updateRun","sizeLimitBytes","batch_ingest_config","size_limit_bytes","batchChunks","currentBatchSizeBytes","k","key","batchItems","reverse","batchItem","stringifiedBatchItem","_postBatchIngestRuns","runId","data","end_time","parent_run_id","readRun","loadChildRuns","child_run_ids","_loadChildRuns","getRunUrl","projectOpts","sessionId","session_id","projectName","readProject","projectId","project","tenantId","_getTenantId","run_","app_path","baseUrl","childRuns","listRuns","treemap","sort","a","b","localeCompare","childRun","child_runs","props","parentRunId","traceId","referenceExampleId","startTime","executionOrder","isRoot","runType","query","traceFilter","treeFilter","select","projectIds","Array","isArray","projectNames","projectIds_","all","name","then","default_select","session","run_type","reference_example","trace_filter","tree_filter","execution_order","parent_run","toISOString","trace","is_root","runsYielded","newRuns","slice","shareRun","shareId","run_id","share_token","v4","unshareRun","readRunSharedLink","listSharedRuns","shareToken","runIds","append","readDatasetSharedSchema","datasetId","datasetName","dataset","readDataset","shareSchema","shareDataset","dataset_id","unshareDataset","readSharedDataset","createProject","description","upsert","projectExtra","referenceDatasetId","upsert_","endpoint","updateProject","endTime","hasProject","includeStats","getProjectUrl","getDatasetUrl","_tenantId","projects","tenant_id","listProjects","nameContains","referenceDatasetName","referenceFree","deleteProject","projectId_","uploadCsv","csvFile","fileName","inputKeys","outputKeys","dataType","formData","FormData","detail","createDataset","data_type","hasDataset","message","toLocaleLowerCase","diffDatasetVersions","fromVersion","toVersion","datasetId_","urlParams","from_version","to_version","readDatasetOpenaiFinetuning","datasetText","line","parse","listDatasets","datasetIds","datasetNameContains","id_","datasets","deleteDataset","createExample","createdAt","exampleId","createdAt_","created_at","createExamples","sourceRunIds","exampleIds","formattedExamples","input","idx","splits","source_run_id","createLLMExample","generation","options","output","createChatExample","generations","finalInput","finalOutput","readExample","listExamples","asOf","inlineS3Urls","dataset_version","inlineS3Urls_","serializedMetadata","examples","deleteExample","updateExample","evaluateRun","evaluator","sourceInfo","referenceExample","reference_example_id","feedbackResult","sourceInfo_","evaluatorInfo","targetRunId","createFeedback","score","comment","correction","feedbackSourceType","sourceRunId","feedbackId","feedbackConfig","comparativeExperimentId","feedback_source","type","feedback","comparative_experiment_id","updateFeedback","feedbackUpdate","readFeedback","deleteFeedback","listFeedback","feedbackKeys","feedbackSourceTypes","join","feedbacks","createPresignedFeedbackToken","feedbackKey","expiration","feedback_key","feedback_config","hours","minutes","days","createComparativeExperiment","experimentIds","reference_dataset_id","experiment_ids","listPresignedFeedbackTokens","tokens","_selectEvalResults","results","results_","logEvaluationFeedback","evaluatorResponse","res","runId_"],"sources":["C:/Users/lucil/Gen-AI-Contest/FrontEnd/kridic-front/node_modules/langsmith/dist/client.js"],"sourcesContent":["import * as uuid from \"uuid\";\nimport { AsyncCaller } from \"./utils/async_caller.js\";\nimport { convertLangChainMessageToExample, isLangChainMessage, } from \"./utils/messages.js\";\nimport { getEnvironmentVariable, getLangChainEnvVarsMetadata, getRuntimeEnvironment, } from \"./utils/env.js\";\nimport { __version__ } from \"./index.js\";\nimport { assertUuid } from \"./utils/_uuid.js\";\nasync function mergeRuntimeEnvIntoRunCreates(runs) {\n    const runtimeEnv = await getRuntimeEnvironment();\n    const envVars = getLangChainEnvVarsMetadata();\n    return runs.map((run) => {\n        const extra = run.extra ?? {};\n        const metadata = extra.metadata;\n        run.extra = {\n            ...extra,\n            runtime: {\n                ...runtimeEnv,\n                ...extra?.runtime,\n            },\n            metadata: {\n                ...envVars,\n                ...(envVars.revision_id || run.revision_id\n                    ? { revision_id: run.revision_id ?? envVars.revision_id }\n                    : {}),\n                ...metadata,\n            },\n        };\n        return run;\n    });\n}\nconst getTracingSamplingRate = () => {\n    const samplingRateStr = getEnvironmentVariable(\"LANGCHAIN_TRACING_SAMPLING_RATE\");\n    if (samplingRateStr === undefined) {\n        return undefined;\n    }\n    const samplingRate = parseFloat(samplingRateStr);\n    if (samplingRate < 0 || samplingRate > 1) {\n        throw new Error(`LANGCHAIN_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n    }\n    return samplingRate;\n};\n// utility functions\nconst isLocalhost = (url) => {\n    const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n    const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n    return (hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\");\n};\nconst raiseForStatus = async (response, operation) => {\n    // consume the response body to release the connection\n    // https://undici.nodejs.org/#/?id=garbage-collection\n    const body = await response.text();\n    if (!response.ok) {\n        throw new Error(`Failed to ${operation}: ${response.status} ${response.statusText} ${body}`);\n    }\n};\nasync function toArray(iterable) {\n    const result = [];\n    for await (const item of iterable) {\n        result.push(item);\n    }\n    return result;\n}\nfunction trimQuotes(str) {\n    if (str === undefined) {\n        return undefined;\n    }\n    return str\n        .trim()\n        .replace(/^\"(.*)\"$/, \"$1\")\n        .replace(/^'(.*)'$/, \"$1\");\n}\nconst handle429 = async (response) => {\n    if (response?.status === 429) {\n        const retryAfter = parseInt(response.headers.get(\"retry-after\") ?? \"30\", 10) * 1000;\n        if (retryAfter > 0) {\n            await new Promise((resolve) => setTimeout(resolve, retryAfter));\n            // Return directly after calling this check\n            return true;\n        }\n    }\n    // Fall back to existing status checks\n    return false;\n};\nexport class Queue {\n    constructor() {\n        Object.defineProperty(this, \"items\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n    }\n    get size() {\n        return this.items.length;\n    }\n    push(item) {\n        // this.items.push is synchronous with promise creation:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\n        return new Promise((resolve) => {\n            this.items.push([item, resolve]);\n        });\n    }\n    pop(upToN) {\n        if (upToN < 1) {\n            throw new Error(\"Number of items to pop off may not be less than 1.\");\n        }\n        const popped = [];\n        while (popped.length < upToN && this.items.length) {\n            const item = this.items.shift();\n            if (item) {\n                popped.push(item);\n            }\n            else {\n                break;\n            }\n        }\n        return [popped.map((it) => it[0]), () => popped.forEach((it) => it[1]())];\n    }\n}\n// 20 MB\nexport const DEFAULT_BATCH_SIZE_LIMIT_BYTES = 20_971_520;\nexport class Client {\n    constructor(config = {}) {\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"webUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"batchIngestCaller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeout_ms\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_tenantId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        Object.defineProperty(this, \"hideInputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"hideOutputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingSampleRate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"sampledPostUuids\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Set()\n        });\n        Object.defineProperty(this, \"autoBatchTracing\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"batchEndpointSupported\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchQueue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Queue()\n        });\n        Object.defineProperty(this, \"pendingAutoBatchedRunLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 100\n        });\n        Object.defineProperty(this, \"autoBatchTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchInitialDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 250\n        });\n        Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 50\n        });\n        Object.defineProperty(this, \"serverInfo\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fetchOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const defaultConfig = Client.getDefaultClientConfig();\n        this.tracingSampleRate = getTracingSamplingRate();\n        this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n        this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n        this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n        this.timeout_ms = config.timeout_ms ?? 12_000;\n        this.caller = new AsyncCaller(config.callerOptions ?? {});\n        this.batchIngestCaller = new AsyncCaller({\n            ...(config.callerOptions ?? {}),\n            onFailedResponseHook: handle429,\n        });\n        this.hideInputs = config.hideInputs ?? defaultConfig.hideInputs;\n        this.hideOutputs = config.hideOutputs ?? defaultConfig.hideOutputs;\n        this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n        this.pendingAutoBatchedRunLimit =\n            config.pendingAutoBatchedRunLimit ?? this.pendingAutoBatchedRunLimit;\n        this.fetchOptions = config.fetchOptions || {};\n    }\n    static getDefaultClientConfig() {\n        const apiKey = getEnvironmentVariable(\"LANGCHAIN_API_KEY\");\n        const apiUrl = getEnvironmentVariable(\"LANGCHAIN_ENDPOINT\") ??\n            \"https://api.smith.langchain.com\";\n        const hideInputs = getEnvironmentVariable(\"LANGCHAIN_HIDE_INPUTS\") === \"true\";\n        const hideOutputs = getEnvironmentVariable(\"LANGCHAIN_HIDE_OUTPUTS\") === \"true\";\n        return {\n            apiUrl: apiUrl,\n            apiKey: apiKey,\n            webUrl: undefined,\n            hideInputs: hideInputs,\n            hideOutputs: hideOutputs,\n        };\n    }\n    getHostUrl() {\n        if (this.webUrl) {\n            return this.webUrl;\n        }\n        else if (isLocalhost(this.apiUrl)) {\n            this.webUrl = \"http://localhost:3000\";\n            return this.webUrl;\n        }\n        else if (this.apiUrl.includes(\"/api\") &&\n            !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n            this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n            return this.webUrl;\n        }\n        else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n            this.webUrl = \"https://dev.smith.langchain.com\";\n            return this.webUrl;\n        }\n        else {\n            this.webUrl = \"https://smith.langchain.com\";\n            return this.webUrl;\n        }\n    }\n    get headers() {\n        const headers = {\n            \"User-Agent\": `langsmith-js/${__version__}`,\n        };\n        if (this.apiKey) {\n            headers[\"x-api-key\"] = `${this.apiKey}`;\n        }\n        return headers;\n    }\n    processInputs(inputs) {\n        if (this.hideInputs === false) {\n            return inputs;\n        }\n        if (this.hideInputs === true) {\n            return {};\n        }\n        if (typeof this.hideInputs === \"function\") {\n            return this.hideInputs(inputs);\n        }\n        return inputs;\n    }\n    processOutputs(outputs) {\n        if (this.hideOutputs === false) {\n            return outputs;\n        }\n        if (this.hideOutputs === true) {\n            return {};\n        }\n        if (typeof this.hideOutputs === \"function\") {\n            return this.hideOutputs(outputs);\n        }\n        return outputs;\n    }\n    prepareRunCreateOrUpdateInputs(run) {\n        const runParams = { ...run };\n        if (runParams.inputs !== undefined) {\n            runParams.inputs = this.processInputs(runParams.inputs);\n        }\n        if (runParams.outputs !== undefined) {\n            runParams.outputs = this.processOutputs(runParams.outputs);\n        }\n        return runParams;\n    }\n    async _getResponse(path, queryParams) {\n        const paramsString = queryParams?.toString() ?? \"\";\n        const url = `${this.apiUrl}${path}?${paramsString}`;\n        const response = await this.caller.call(fetch, url, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n        }\n        return response;\n    }\n    async _get(path, queryParams) {\n        const response = await this._getResponse(path, queryParams);\n        return response.json();\n    }\n    async *_getPaginated(path, queryParams = new URLSearchParams()) {\n        let offset = Number(queryParams.get(\"offset\")) || 0;\n        const limit = Number(queryParams.get(\"limit\")) || 100;\n        while (true) {\n            queryParams.set(\"offset\", String(offset));\n            queryParams.set(\"limit\", String(limit));\n            const url = `${this.apiUrl}${path}?${queryParams}`;\n            const response = await this.caller.call(fetch, url, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            if (!response.ok) {\n                throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n            }\n            const items = await response.json();\n            if (items.length === 0) {\n                break;\n            }\n            yield items;\n            if (items.length < limit) {\n                break;\n            }\n            offset += items.length;\n        }\n    }\n    async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n        const bodyParams = body ? { ...body } : {};\n        while (true) {\n            const response = await this.caller.call(fetch, `${this.apiUrl}${path}`, {\n                method: requestMethod,\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: JSON.stringify(bodyParams),\n            });\n            const responseBody = await response.json();\n            if (!responseBody) {\n                break;\n            }\n            if (!responseBody[dataKey]) {\n                break;\n            }\n            yield responseBody[dataKey];\n            const cursors = responseBody.cursors;\n            if (!cursors) {\n                break;\n            }\n            if (!cursors.next) {\n                break;\n            }\n            bodyParams.cursor = cursors.next;\n        }\n    }\n    _filterForSampling(runs, patch = false) {\n        if (this.tracingSampleRate === undefined) {\n            return runs;\n        }\n        if (patch) {\n            const sampled = [];\n            for (const run of runs) {\n                if (this.sampledPostUuids.has(run.id)) {\n                    sampled.push(run);\n                    this.sampledPostUuids.delete(run.id);\n                }\n            }\n            return sampled;\n        }\n        else {\n            const sampled = [];\n            for (const run of runs) {\n                if (Math.random() < this.tracingSampleRate) {\n                    sampled.push(run);\n                    this.sampledPostUuids.add(run.id);\n                }\n            }\n            return sampled;\n        }\n    }\n    async drainAutoBatchQueue() {\n        while (this.autoBatchQueue.size >= 0) {\n            const [batch, done] = this.autoBatchQueue.pop(this.pendingAutoBatchedRunLimit);\n            if (!batch.length) {\n                done();\n                return;\n            }\n            try {\n                await this.batchIngestRuns({\n                    runCreates: batch\n                        .filter((item) => item.action === \"create\")\n                        .map((item) => item.item),\n                    runUpdates: batch\n                        .filter((item) => item.action === \"update\")\n                        .map((item) => item.item),\n                });\n            }\n            finally {\n                done();\n            }\n        }\n    }\n    async processRunOperation(item, immediatelyTriggerBatch) {\n        const oldTimeout = this.autoBatchTimeout;\n        clearTimeout(this.autoBatchTimeout);\n        this.autoBatchTimeout = undefined;\n        const itemPromise = this.autoBatchQueue.push(item);\n        if (immediatelyTriggerBatch ||\n            this.autoBatchQueue.size > this.pendingAutoBatchedRunLimit) {\n            await this.drainAutoBatchQueue();\n        }\n        if (this.autoBatchQueue.size > 0) {\n            this.autoBatchTimeout = setTimeout(() => {\n                this.autoBatchTimeout = undefined;\n                // This error would happen in the background and is uncatchable\n                // from the outside. So just log instead.\n                void this.drainAutoBatchQueue().catch(console.error);\n            }, oldTimeout\n                ? this.autoBatchAggregationDelayMs\n                : this.autoBatchInitialDelayMs);\n        }\n        return itemPromise;\n    }\n    async _getServerInfo() {\n        const response = await fetch(`${this.apiUrl}/info`, {\n            method: \"GET\",\n            headers: { Accept: \"application/json\" },\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        if (!response.ok) {\n            // consume the response body to release the connection\n            // https://undici.nodejs.org/#/?id=garbage-collection\n            await response.text();\n            throw new Error(\"Failed to retrieve server info.\");\n        }\n        return response.json();\n    }\n    async batchEndpointIsSupported() {\n        try {\n            this.serverInfo = await this._getServerInfo();\n        }\n        catch (e) {\n            return false;\n        }\n        return true;\n    }\n    async createRun(run) {\n        if (!this._filterForSampling([run]).length) {\n            return;\n        }\n        const headers = { ...this.headers, \"Content-Type\": \"application/json\" };\n        const session_name = run.project_name;\n        delete run.project_name;\n        const runCreate = this.prepareRunCreateOrUpdateInputs({\n            session_name,\n            ...run,\n            start_time: run.start_time ?? Date.now(),\n        });\n        if (this.autoBatchTracing &&\n            runCreate.trace_id !== undefined &&\n            runCreate.dotted_order !== undefined) {\n            void this.processRunOperation({\n                action: \"create\",\n                item: runCreate,\n            }).catch(console.error);\n            return;\n        }\n        const mergedRunCreateParams = await mergeRuntimeEnvIntoRunCreates([\n            runCreate,\n        ]);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs`, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(mergedRunCreateParams[0]),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"create run\");\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */\n    async batchIngestRuns({ runCreates, runUpdates, }) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        let preparedCreateParams = runCreates?.map((create) => this.prepareRunCreateOrUpdateInputs(create)) ?? [];\n        let preparedUpdateParams = runUpdates?.map((update) => this.prepareRunCreateOrUpdateInputs(update)) ?? [];\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run) => {\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams) {\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam,\n                    };\n                }\n                else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        const rawBatch = {\n            post: this._filterForSampling(preparedCreateParams),\n            patch: this._filterForSampling(preparedUpdateParams, true),\n        };\n        if (!rawBatch.post.length && !rawBatch.patch.length) {\n            return;\n        }\n        preparedCreateParams = await mergeRuntimeEnvIntoRunCreates(preparedCreateParams);\n        if (this.batchEndpointSupported === undefined) {\n            this.batchEndpointSupported = await this.batchEndpointIsSupported();\n        }\n        if (!this.batchEndpointSupported) {\n            this.autoBatchTracing = false;\n            for (const preparedCreateParam of rawBatch.post) {\n                await this.createRun(preparedCreateParam);\n            }\n            for (const preparedUpdateParam of rawBatch.patch) {\n                if (preparedUpdateParam.id !== undefined) {\n                    await this.updateRun(preparedUpdateParam.id, preparedUpdateParam);\n                }\n            }\n            return;\n        }\n        const sizeLimitBytes = this.serverInfo?.batch_ingest_config?.size_limit_bytes ??\n            DEFAULT_BATCH_SIZE_LIMIT_BYTES;\n        const batchChunks = {\n            post: [],\n            patch: [],\n        };\n        let currentBatchSizeBytes = 0;\n        for (const k of [\"post\", \"patch\"]) {\n            const key = k;\n            const batchItems = rawBatch[key].reverse();\n            let batchItem = batchItems.pop();\n            while (batchItem !== undefined) {\n                const stringifiedBatchItem = JSON.stringify(batchItem);\n                if (currentBatchSizeBytes > 0 &&\n                    currentBatchSizeBytes + stringifiedBatchItem.length > sizeLimitBytes) {\n                    await this._postBatchIngestRuns(JSON.stringify(batchChunks));\n                    currentBatchSizeBytes = 0;\n                    batchChunks.post = [];\n                    batchChunks.patch = [];\n                }\n                currentBatchSizeBytes += stringifiedBatchItem.length;\n                batchChunks[key].push(batchItem);\n                batchItem = batchItems.pop();\n            }\n        }\n        if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {\n            await this._postBatchIngestRuns(JSON.stringify(batchChunks));\n        }\n    }\n    async _postBatchIngestRuns(body) {\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n            Accept: \"application/json\",\n        };\n        const response = await this.batchIngestCaller.call(fetch, `${this.apiUrl}/runs/batch`, {\n            method: \"POST\",\n            headers,\n            body: body,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"batch create run\");\n    }\n    async updateRun(runId, run) {\n        assertUuid(runId);\n        if (run.inputs) {\n            run.inputs = this.processInputs(run.inputs);\n        }\n        if (run.outputs) {\n            run.outputs = this.processOutputs(run.outputs);\n        }\n        // TODO: Untangle types\n        const data = { ...run, id: runId };\n        if (!this._filterForSampling([data], true).length) {\n            return;\n        }\n        if (this.autoBatchTracing &&\n            data.trace_id !== undefined &&\n            data.dotted_order !== undefined) {\n            if (run.end_time !== undefined && data.parent_run_id === undefined) {\n                // Trigger a batch as soon as a root trace ends and block to ensure trace finishes\n                // in serverless environments.\n                await this.processRunOperation({ action: \"update\", item: data }, true);\n                return;\n            }\n            else {\n                void this.processRunOperation({ action: \"update\", item: data }).catch(console.error);\n            }\n            return;\n        }\n        const headers = { ...this.headers, \"Content-Type\": \"application/json\" };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}`, {\n            method: \"PATCH\",\n            headers,\n            body: JSON.stringify(run),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"update run\");\n    }\n    async readRun(runId, { loadChildRuns } = { loadChildRuns: false }) {\n        assertUuid(runId);\n        let run = await this._get(`/runs/${runId}`);\n        if (loadChildRuns && run.child_run_ids) {\n            run = await this._loadChildRuns(run);\n        }\n        return run;\n    }\n    async getRunUrl({ runId, run, projectOpts, }) {\n        if (run !== undefined) {\n            let sessionId;\n            if (run.session_id) {\n                sessionId = run.session_id;\n            }\n            else if (projectOpts?.projectName) {\n                sessionId = (await this.readProject({ projectName: projectOpts?.projectName })).id;\n            }\n            else if (projectOpts?.projectId) {\n                sessionId = projectOpts?.projectId;\n            }\n            else {\n                const project = await this.readProject({\n                    projectName: getEnvironmentVariable(\"LANGCHAIN_PROJECT\") || \"default\",\n                });\n                sessionId = project.id;\n            }\n            const tenantId = await this._getTenantId();\n            return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n        }\n        else if (runId !== undefined) {\n            const run_ = await this.readRun(runId);\n            if (!run_.app_path) {\n                throw new Error(`Run ${runId} has no app_path`);\n            }\n            const baseUrl = this.getHostUrl();\n            return `${baseUrl}${run_.app_path}`;\n        }\n        else {\n            throw new Error(\"Must provide either runId or run\");\n        }\n    }\n    async _loadChildRuns(run) {\n        const childRuns = await toArray(this.listRuns({ id: run.child_run_ids }));\n        const treemap = {};\n        const runs = {};\n        // TODO: make dotted order required when the migration finishes\n        childRuns.sort((a, b) => (a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n        for (const childRun of childRuns) {\n            if (childRun.parent_run_id === null ||\n                childRun.parent_run_id === undefined) {\n                throw new Error(`Child run ${childRun.id} has no parent`);\n            }\n            if (!(childRun.parent_run_id in treemap)) {\n                treemap[childRun.parent_run_id] = [];\n            }\n            treemap[childRun.parent_run_id].push(childRun);\n            runs[childRun.id] = childRun;\n        }\n        run.child_runs = treemap[run.id] || [];\n        for (const runId in treemap) {\n            if (runId !== run.id) {\n                runs[runId].child_runs = treemap[runId];\n            }\n        }\n        return run;\n    }\n    /**\n     * List runs from the LangSmith server.\n     * @param projectId - The ID of the project to filter by.\n     * @param projectName - The name of the project to filter by.\n     * @param parentRunId - The ID of the parent run to filter by.\n     * @param traceId - The ID of the trace to filter by.\n     * @param referenceExampleId - The ID of the reference example to filter by.\n     * @param startTime - The start time to filter by.\n     * @param isRoot - Indicates whether to only return root runs.\n     * @param runType - The run type to filter by.\n     * @param error - Indicates whether to filter by error runs.\n     * @param id - The ID of the run to filter by.\n     * @param query - The query string to filter by.\n     * @param filter - The filter string to apply to the run spans.\n     * @param traceFilter - The filter string to apply on the root run of the trace.\n     * @param limit - The maximum number of runs to retrieve.\n     * @returns {AsyncIterable<Run>} - The runs.\n     *\n     * @example\n     * // List all runs in a project\n     * const projectRuns = client.listRuns({ projectName: \"<your_project>\" });\n     *\n     * @example\n     * // List LLM and Chat runs in the last 24 hours\n     * const todaysLLMRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),\n     *   run_type: \"llm\",\n     * });\n     *\n     * @example\n     * // List traces in a project\n     * const rootRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   execution_order: 1,\n     * });\n     *\n     * @example\n     * // List runs without errors\n     * const correctRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   error: false,\n     * });\n     *\n     * @example\n     * // List runs by run ID\n     * const runIds = [\n     *   \"a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836\",\n     *   \"9398e6be-964f-4aa4-8ae9-ad78cd4b7074\",\n     * ];\n     * const selectedRuns = client.listRuns({ run_ids: runIds });\n     *\n     * @example\n     * // List all \"chain\" type runs that took more than 10 seconds and had `total_tokens` greater than 5000\n     * const chainRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(eq(run_type, \"chain\"), gt(latency, 10), gt(total_tokens, 5000))',\n     * });\n     *\n     * @example\n     * // List all runs called \"extractor\" whose root of the trace was assigned feedback \"user_score\" score of 1\n     * const goodExtractorRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'eq(name, \"extractor\")',\n     *   traceFilter: 'and(eq(feedback_key, \"user_score\"), eq(feedback_score, 1))',\n     * });\n     *\n     * @example\n     * // List all runs that started after a specific timestamp and either have \"error\" not equal to null or a \"Correctness\" feedback score equal to 0\n     * const complexRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(gt(start_time, \"2023-07-15T12:34:56Z\"), or(neq(error, null), and(eq(feedback_key, \"Correctness\"), eq(feedback_score, 0.0))))',\n     * });\n     *\n     * @example\n     * // List all runs where `tags` include \"experimental\" or \"beta\" and `latency` is greater than 2 seconds\n     * const taggedRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(or(has(tags, \"experimental\"), has(tags, \"beta\")), gt(latency, 2))',\n     * });\n     */\n    async *listRuns(props) {\n        const { projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, isRoot, runType, error, id, query, filter, traceFilter, treeFilter, limit, select, } = props;\n        let projectIds = [];\n        if (projectId) {\n            projectIds = Array.isArray(projectId) ? projectId : [projectId];\n        }\n        if (projectName) {\n            const projectNames = Array.isArray(projectName)\n                ? projectName\n                : [projectName];\n            const projectIds_ = await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)));\n            projectIds.push(...projectIds_);\n        }\n        const default_select = [\n            \"app_path\",\n            \"child_run_ids\",\n            \"completion_cost\",\n            \"completion_tokens\",\n            \"dotted_order\",\n            \"end_time\",\n            \"error\",\n            \"events\",\n            \"extra\",\n            \"feedback_stats\",\n            \"first_token_time\",\n            \"id\",\n            \"inputs\",\n            \"name\",\n            \"outputs\",\n            \"parent_run_id\",\n            \"parent_run_ids\",\n            \"prompt_cost\",\n            \"prompt_tokens\",\n            \"reference_example_id\",\n            \"run_type\",\n            \"session_id\",\n            \"start_time\",\n            \"status\",\n            \"tags\",\n            \"total_cost\",\n            \"total_tokens\",\n            \"trace_id\",\n        ];\n        const body = {\n            session: projectIds.length ? projectIds : null,\n            run_type: runType,\n            reference_example: referenceExampleId,\n            query,\n            filter,\n            trace_filter: traceFilter,\n            tree_filter: treeFilter,\n            execution_order: executionOrder,\n            parent_run: parentRunId,\n            start_time: startTime ? startTime.toISOString() : null,\n            error,\n            id,\n            limit,\n            trace: traceId,\n            select: select ? select : default_select,\n            is_root: isRoot,\n        };\n        let runsYielded = 0;\n        for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)) {\n            if (limit) {\n                if (runsYielded >= limit) {\n                    break;\n                }\n                if (runs.length + runsYielded > limit) {\n                    const newRuns = runs.slice(0, limit - runsYielded);\n                    yield* newRuns;\n                    break;\n                }\n                runsYielded += runs.length;\n                yield* runs;\n            }\n            else {\n                yield* runs;\n            }\n        }\n    }\n    async shareRun(runId, { shareId } = {}) {\n        const data = {\n            run_id: runId,\n            share_token: shareId || uuid.v4(),\n        };\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            throw new Error(\"Invalid response from server\");\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async unshareRun(runId) {\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"unshare run\");\n    }\n    async readRunSharedLink(runId) {\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            return undefined;\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async listSharedRuns(shareToken, { runIds, } = {}) {\n        const queryParams = new URLSearchParams({\n            share_token: shareToken,\n        });\n        if (runIds !== undefined) {\n            for (const runId of runIds) {\n                queryParams.append(\"id\", runId);\n            }\n        }\n        assertUuid(shareToken);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const runs = await response.json();\n        return runs;\n    }\n    async readDatasetSharedSchema(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId = dataset.id;\n        }\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async shareDataset(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId = dataset.id;\n        }\n        const data = {\n            dataset_id: datasetId,\n        };\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async unshareDataset(datasetId) {\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"unshare dataset\");\n    }\n    async readSharedDataset(shareToken) {\n        assertUuid(shareToken);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/datasets`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const dataset = await response.json();\n        return dataset;\n    }\n    async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null, }) {\n        const upsert_ = upsert ? `?upsert=true` : \"\";\n        const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n        const extra = projectExtra || {};\n        if (metadata) {\n            extra[\"metadata\"] = metadata;\n        }\n        const body = {\n            name: projectName,\n            extra,\n            description,\n        };\n        if (referenceDatasetId !== null) {\n            body[\"reference_dataset_id\"] = referenceDatasetId;\n        }\n        const response = await this.caller.call(fetch, endpoint, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            throw new Error(`Failed to create session ${projectName}: ${response.status} ${response.statusText}`);\n        }\n        return result;\n    }\n    async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null, }) {\n        const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n        let extra = projectExtra;\n        if (metadata) {\n            extra = { ...(extra || {}), metadata };\n        }\n        const body = {\n            name,\n            extra,\n            description,\n            end_time: endTime ? new Date(endTime).toISOString() : null,\n        };\n        const response = await this.caller.call(fetch, endpoint, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            throw new Error(`Failed to update project ${projectId}: ${response.status} ${response.statusText}`);\n        }\n        return result;\n    }\n    async hasProject({ projectId, projectName, }) {\n        // TODO: Add a head request\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId !== undefined) {\n            assertUuid(projectId);\n            path += `/${projectId}`;\n        }\n        else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        }\n        else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        const response = await this.caller.call(fetch, `${this.apiUrl}${path}?${params}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        // consume the response body to release the connection\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        try {\n            const result = await response.json();\n            if (!response.ok) {\n                return false;\n            }\n            // If it's OK and we're querying by name, need to check the list is not empty\n            if (Array.isArray(result)) {\n                return result.length > 0;\n            }\n            // projectId querying\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    async readProject({ projectId, projectName, includeStats, }) {\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId !== undefined) {\n            assertUuid(projectId);\n            path += `/${projectId}`;\n        }\n        else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        }\n        else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        if (includeStats !== undefined) {\n            params.append(\"include_stats\", includeStats.toString());\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async getProjectUrl({ projectId, projectName, }) {\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide either projectName or projectId\");\n        }\n        const project = await this.readProject({ projectId, projectName });\n        const tenantId = await this._getTenantId();\n        return `${this.getHostUrl()}/o/${tenantId}/projects/p/${project.id}`;\n    }\n    async getDatasetUrl({ datasetId, datasetName, }) {\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const dataset = await this.readDataset({ datasetId, datasetName });\n        const tenantId = await this._getTenantId();\n        return `${this.getHostUrl()}/o/${tenantId}/datasets/${dataset.id}`;\n    }\n    async _getTenantId() {\n        if (this._tenantId !== null) {\n            return this._tenantId;\n        }\n        const queryParams = new URLSearchParams({ limit: \"1\" });\n        for await (const projects of this._getPaginated(\"/sessions\", queryParams)) {\n            this._tenantId = projects[0].tenant_id;\n            return projects[0].tenant_id;\n        }\n        throw new Error(\"No projects found to resolve tenant.\");\n    }\n    async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, referenceFree, } = {}) {\n        const params = new URLSearchParams();\n        if (projectIds !== undefined) {\n            for (const projectId of projectIds) {\n                params.append(\"id\", projectId);\n            }\n        }\n        if (name !== undefined) {\n            params.append(\"name\", name);\n        }\n        if (nameContains !== undefined) {\n            params.append(\"name_contains\", nameContains);\n        }\n        if (referenceDatasetId !== undefined) {\n            params.append(\"reference_dataset\", referenceDatasetId);\n        }\n        else if (referenceDatasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName: referenceDatasetName,\n            });\n            params.append(\"reference_dataset\", dataset.id);\n        }\n        if (referenceFree !== undefined) {\n            params.append(\"reference_free\", referenceFree.toString());\n        }\n        for await (const projects of this._getPaginated(\"/sessions\", params)) {\n            yield* projects;\n        }\n    }\n    async deleteProject({ projectId, projectName, }) {\n        let projectId_;\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        else if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId === undefined) {\n            projectId_ = (await this.readProject({ projectName })).id;\n        }\n        else {\n            projectId_ = projectId;\n        }\n        assertUuid(projectId_);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/sessions/${projectId_}`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, `delete session ${projectId_} (${projectName})`);\n    }\n    async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name, }) {\n        const url = `${this.apiUrl}/datasets/upload`;\n        const formData = new FormData();\n        formData.append(\"file\", csvFile, fileName);\n        inputKeys.forEach((key) => {\n            formData.append(\"input_keys\", key);\n        });\n        outputKeys.forEach((key) => {\n            formData.append(\"output_keys\", key);\n        });\n        if (description) {\n            formData.append(\"description\", description);\n        }\n        if (dataType) {\n            formData.append(\"data_type\", dataType);\n        }\n        if (name) {\n            formData.append(\"name\", name);\n        }\n        const response = await this.caller.call(fetch, url, {\n            method: \"POST\",\n            headers: this.headers,\n            body: formData,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        if (!response.ok) {\n            const result = await response.json();\n            if (result.detail && result.detail.includes(\"already exists\")) {\n                throw new Error(`Dataset ${fileName} already exists`);\n            }\n            throw new Error(`Failed to upload CSV: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createDataset(name, { description, dataType, } = {}) {\n        const body = {\n            name,\n            description,\n        };\n        if (dataType) {\n            body.data_type = dataType;\n        }\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        if (!response.ok) {\n            const result = await response.json();\n            if (result.detail && result.detail.includes(\"already exists\")) {\n                throw new Error(`Dataset ${name} already exists`);\n            }\n            throw new Error(`Failed to create dataset ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async readDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        // limit to 1 result\n        const params = new URLSearchParams({ limit: \"1\" });\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId !== undefined) {\n            assertUuid(datasetId);\n            path += `/${datasetId}`;\n        }\n        else if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async hasDataset({ datasetId, datasetName, }) {\n        try {\n            await this.readDataset({ datasetId, datasetName });\n            return true;\n        }\n        catch (e) {\n            if (\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            e instanceof Error &&\n                e.message.toLocaleLowerCase().includes(\"not found\")) {\n                return false;\n            }\n            throw e;\n        }\n    }\n    async diffDatasetVersions({ datasetId, datasetName, fromVersion, toVersion, }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        const urlParams = new URLSearchParams({\n            from_version: typeof fromVersion === \"string\"\n                ? fromVersion\n                : fromVersion.toISOString(),\n            to_version: typeof toVersion === \"string\" ? toVersion : toVersion.toISOString(),\n        });\n        const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);\n        return response;\n    }\n    async readDatasetOpenaiFinetuning({ datasetId, datasetName, }) {\n        const path = \"/datasets\";\n        if (datasetId !== undefined) {\n            // do nothing\n        }\n        else if (datasetName !== undefined) {\n            datasetId = (await this.readDataset({ datasetName })).id;\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n        const datasetText = await response.text();\n        const dataset = datasetText\n            .trim()\n            .split(\"\\n\")\n            .map((line) => JSON.parse(line));\n        return dataset;\n    }\n    async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains, } = {}) {\n        const path = \"/datasets\";\n        const params = new URLSearchParams({\n            limit: limit.toString(),\n            offset: offset.toString(),\n        });\n        if (datasetIds !== undefined) {\n            for (const id_ of datasetIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        if (datasetNameContains !== undefined) {\n            params.append(\"name_contains\", datasetNameContains);\n        }\n        for await (const datasets of this._getPaginated(path, params)) {\n            yield* datasets;\n        }\n    }\n    async deleteDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        let datasetId_ = datasetId;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        if (datasetId_ !== undefined) {\n            assertUuid(datasetId_);\n            path += `/${datasetId_}`;\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async createExample(inputs, outputs, { datasetId, datasetName, createdAt, exampleId, metadata, split, }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        const createdAt_ = createdAt || new Date();\n        const data = {\n            dataset_id: datasetId_,\n            inputs,\n            outputs,\n            created_at: createdAt_?.toISOString(),\n            id: exampleId,\n            metadata,\n            split,\n        };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to create example: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createExamples(props) {\n        const { inputs, outputs, metadata, sourceRunIds, exampleIds, datasetId, datasetName, } = props;\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        const formattedExamples = inputs.map((input, idx) => {\n            return {\n                dataset_id: datasetId_,\n                inputs: input,\n                outputs: outputs ? outputs[idx] : undefined,\n                metadata: metadata ? metadata[idx] : undefined,\n                split: props.splits ? props.splits[idx] : undefined,\n                id: exampleIds ? exampleIds[idx] : undefined,\n                source_run_id: sourceRunIds ? sourceRunIds[idx] : undefined,\n            };\n        });\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples/bulk`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(formattedExamples),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to create examples: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createLLMExample(input, generation, options) {\n        return this.createExample({ input }, { output: generation }, options);\n    }\n    async createChatExample(input, generations, options) {\n        const finalInput = input.map((message) => {\n            if (isLangChainMessage(message)) {\n                return convertLangChainMessageToExample(message);\n            }\n            return message;\n        });\n        const finalOutput = isLangChainMessage(generations)\n            ? convertLangChainMessageToExample(generations)\n            : generations;\n        return this.createExample({ input: finalInput }, { output: finalOutput }, options);\n    }\n    async readExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        return await this._get(path);\n    }\n    async *listExamples({ datasetId, datasetName, exampleIds, asOf, splits, inlineS3Urls, metadata, } = {}) {\n        let datasetId_;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId !== undefined) {\n            datasetId_ = datasetId;\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        else {\n            throw new Error(\"Must provide a datasetName or datasetId\");\n        }\n        const params = new URLSearchParams({ dataset: datasetId_ });\n        const dataset_version = asOf\n            ? typeof asOf === \"string\"\n                ? asOf\n                : asOf?.toISOString()\n            : undefined;\n        if (dataset_version) {\n            params.append(\"as_of\", dataset_version);\n        }\n        const inlineS3Urls_ = inlineS3Urls ?? true;\n        params.append(\"inline_s3_urls\", inlineS3Urls_.toString());\n        if (exampleIds !== undefined) {\n            for (const id_ of exampleIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        if (splits !== undefined) {\n            for (const split of splits) {\n                params.append(\"splits\", split);\n            }\n        }\n        if (metadata !== undefined) {\n            const serializedMetadata = JSON.stringify(metadata);\n            params.append(\"metadata\", serializedMetadata);\n        }\n        for await (const examples of this._getPaginated(\"/examples\", params)) {\n            yield* examples;\n        }\n    }\n    async deleteExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async updateExample(exampleId, update) {\n        assertUuid(exampleId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples/${exampleId}`, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(update),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to update example ${exampleId}: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample, } = { loadChildRuns: false }) {\n        let run_;\n        if (typeof run === \"string\") {\n            run_ = await this.readRun(run, { loadChildRuns });\n        }\n        else if (typeof run === \"object\" && \"id\" in run) {\n            run_ = run;\n        }\n        else {\n            throw new Error(`Invalid run type: ${typeof run}`);\n        }\n        if (run_.reference_example_id !== null &&\n            run_.reference_example_id !== undefined) {\n            referenceExample = await this.readExample(run_.reference_example_id);\n        }\n        const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n        let sourceInfo_ = sourceInfo ?? {};\n        if (feedbackResult.evaluatorInfo) {\n            sourceInfo_ = { ...sourceInfo_, ...feedbackResult.evaluatorInfo };\n        }\n        const runId = feedbackResult.targetRunId ?? run_.id;\n        return await this.createFeedback(runId, feedbackResult.key, {\n            score: feedbackResult?.score,\n            value: feedbackResult?.value,\n            comment: feedbackResult?.comment,\n            correction: feedbackResult?.correction,\n            sourceInfo: sourceInfo_,\n            feedbackSourceType: \"model\",\n            sourceRunId: feedbackResult?.sourceRunId,\n        });\n    }\n    async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = \"api\", sourceRunId, feedbackId, feedbackConfig, projectId, comparativeExperimentId, }) {\n        if (!runId && !projectId) {\n            throw new Error(\"One of runId or projectId must be provided\");\n        }\n        if (runId && projectId) {\n            throw new Error(\"Only one of runId or projectId can be provided\");\n        }\n        const feedback_source = {\n            type: feedbackSourceType ?? \"api\",\n            metadata: sourceInfo ?? {},\n        };\n        if (sourceRunId !== undefined &&\n            feedback_source?.metadata !== undefined &&\n            !feedback_source.metadata[\"__run\"]) {\n            feedback_source.metadata[\"__run\"] = { run_id: sourceRunId };\n        }\n        if (feedback_source?.metadata !== undefined &&\n            feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n            assertUuid(feedback_source.metadata[\"__run\"].run_id);\n        }\n        const feedback = {\n            id: feedbackId ?? uuid.v4(),\n            run_id: runId,\n            key,\n            score,\n            value,\n            correction,\n            comment,\n            feedback_source: feedback_source,\n            comparative_experiment_id: comparativeExperimentId,\n            feedbackConfig,\n            session_id: projectId,\n        };\n        const url = `${this.apiUrl}/feedback`;\n        const response = await this.caller.call(fetch, url, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(feedback),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"create feedback\");\n        return feedback;\n    }\n    async updateFeedback(feedbackId, { score, value, correction, comment, }) {\n        const feedbackUpdate = {};\n        if (score !== undefined && score !== null) {\n            feedbackUpdate[\"score\"] = score;\n        }\n        if (value !== undefined && value !== null) {\n            feedbackUpdate[\"value\"] = value;\n        }\n        if (correction !== undefined && correction !== null) {\n            feedbackUpdate[\"correction\"] = correction;\n        }\n        if (comment !== undefined && comment !== null) {\n            feedbackUpdate[\"comment\"] = comment;\n        }\n        assertUuid(feedbackId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/feedback/${feedbackId}`, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(feedbackUpdate),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"update feedback\");\n    }\n    async readFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this._get(path);\n        return response;\n    }\n    async deleteFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes, } = {}) {\n        const queryParams = new URLSearchParams();\n        if (runIds) {\n            queryParams.append(\"run\", runIds.join(\",\"));\n        }\n        if (feedbackKeys) {\n            for (const key of feedbackKeys) {\n                queryParams.append(\"key\", key);\n            }\n        }\n        if (feedbackSourceTypes) {\n            for (const type of feedbackSourceTypes) {\n                queryParams.append(\"source\", type);\n            }\n        }\n        for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)) {\n            yield* feedbacks;\n        }\n    }\n    /**\n     * Creates a presigned feedback token and URL.\n     *\n     * The token can be used to authorize feedback metrics without\n     * needing an API key. This is useful for giving browser-based\n     * applications the ability to submit feedback without needing\n     * to expose an API key.\n     *\n     * @param runId - The ID of the run.\n     * @param feedbackKey - The feedback key.\n     * @param options - Additional options for the token.\n     * @param options.expiration - The expiration time for the token.\n     *\n     * @returns A promise that resolves to a FeedbackIngestToken.\n     */\n    async createPresignedFeedbackToken(runId, feedbackKey, { expiration, feedbackConfig, } = {}) {\n        const body = {\n            run_id: runId,\n            feedback_key: feedbackKey,\n            feedback_config: feedbackConfig,\n        };\n        if (expiration) {\n            if (typeof expiration === \"string\") {\n                body[\"expires_at\"] = expiration;\n            }\n            else if (expiration?.hours || expiration?.minutes || expiration?.days) {\n                body[\"expires_in\"] = expiration;\n            }\n        }\n        else {\n            body[\"expires_in\"] = {\n                hours: 3,\n            };\n        }\n        const response = await this.caller.call(fetch, `${this.apiUrl}/feedback/tokens`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const result = await response.json();\n        return result;\n    }\n    async createComparativeExperiment({ name, experimentIds, referenceDatasetId, createdAt, description, metadata, id, }) {\n        if (experimentIds.length === 0) {\n            throw new Error(\"At least one experiment is required\");\n        }\n        if (!referenceDatasetId) {\n            referenceDatasetId = (await this.readProject({\n                projectId: experimentIds[0],\n            })).reference_dataset_id;\n        }\n        if (!referenceDatasetId == null) {\n            throw new Error(\"A reference dataset is required\");\n        }\n        const body = {\n            id,\n            name,\n            experiment_ids: experimentIds,\n            reference_dataset_id: referenceDatasetId,\n            description,\n            created_at: (createdAt ?? new Date())?.toISOString(),\n            extra: {},\n        };\n        if (metadata)\n            body.extra[\"metadata\"] = metadata;\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/comparative`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        return await response.json();\n    }\n    /**\n     * Retrieves a list of presigned feedback tokens for a given run ID.\n     * @param runId The ID of the run.\n     * @returns An async iterable of FeedbackIngestToken objects.\n     */\n    async *listPresignedFeedbackTokens(runId) {\n        assertUuid(runId);\n        const params = new URLSearchParams({ run_id: runId });\n        for await (const tokens of this._getPaginated(\"/feedback/tokens\", params)) {\n            yield* tokens;\n        }\n    }\n    _selectEvalResults(results) {\n        let results_;\n        if (\"results\" in results) {\n            results_ = results.results;\n        }\n        else {\n            results_ = [results];\n        }\n        return results_;\n    }\n    async logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n        const results = this._selectEvalResults(evaluatorResponse);\n        for (const res of results) {\n            let sourceInfo_ = sourceInfo || {};\n            if (res.evaluatorInfo) {\n                sourceInfo_ = { ...res.evaluatorInfo, ...sourceInfo_ };\n            }\n            let runId_ = null;\n            if (res.targetRunId) {\n                runId_ = res.targetRunId;\n            }\n            else if (run) {\n                runId_ = run.id;\n            }\n            await this.createFeedback(runId_, res.key, {\n                score: res.score,\n                value: res.value,\n                comment: res.comment,\n                correction: res.correction,\n                sourceInfo: sourceInfo_,\n                sourceRunId: res.sourceRunId,\n                feedbackConfig: res.feedbackConfig,\n                feedbackSourceType: \"model\",\n            });\n        }\n        return results;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}