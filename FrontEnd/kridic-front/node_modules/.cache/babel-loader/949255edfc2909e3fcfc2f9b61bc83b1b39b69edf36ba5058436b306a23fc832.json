{"ast":null,"code":"import { CallbackManager, ensureHandler } from \"../callbacks/manager.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nexport const DEFAULT_RECURSION_LIMIT = 25;\nexport async function getCallbackManagerForConfig(config) {\n  return CallbackManager.configure(config?.callbacks, undefined, config?.tags, undefined, config?.metadata);\n}\nexport function mergeConfigs(...configs) {\n  // We do not want to call ensureConfig on the empty state here as this may cause\n  // double loading of callbacks if async local storage is being used.\n  const copy = {};\n  for (const options of configs.filter(c => !!c)) {\n    for (const key of Object.keys(options)) {\n      if (key === \"metadata\") {\n        copy[key] = {\n          ...copy[key],\n          ...options[key]\n        };\n      } else if (key === \"tags\") {\n        const baseKeys = copy[key] ?? [];\n        copy[key] = [...new Set(baseKeys.concat(options[key] ?? []))];\n      } else if (key === \"configurable\") {\n        copy[key] = {\n          ...copy[key],\n          ...options[key]\n        };\n      } else if (key === \"callbacks\") {\n        const baseCallbacks = copy.callbacks;\n        const providedCallbacks = options.callbacks;\n        // callbacks can be either undefined, Array<handler> or manager\n        // so merging two callbacks values has 6 cases\n        if (Array.isArray(providedCallbacks)) {\n          if (!baseCallbacks) {\n            copy.callbacks = providedCallbacks;\n          } else if (Array.isArray(baseCallbacks)) {\n            copy.callbacks = baseCallbacks.concat(providedCallbacks);\n          } else {\n            // baseCallbacks is a manager\n            const manager = baseCallbacks.copy();\n            for (const callback of providedCallbacks) {\n              manager.addHandler(ensureHandler(callback), true);\n            }\n            copy.callbacks = manager;\n          }\n        } else if (providedCallbacks) {\n          // providedCallbacks is a manager\n          if (!baseCallbacks) {\n            copy.callbacks = providedCallbacks;\n          } else if (Array.isArray(baseCallbacks)) {\n            const manager = providedCallbacks.copy();\n            for (const callback of baseCallbacks) {\n              manager.addHandler(ensureHandler(callback), true);\n            }\n            copy.callbacks = manager;\n          } else {\n            // baseCallbacks is also a manager\n            copy.callbacks = new CallbackManager(providedCallbacks._parentRunId, {\n              handlers: baseCallbacks.handlers.concat(providedCallbacks.handlers),\n              inheritableHandlers: baseCallbacks.inheritableHandlers.concat(providedCallbacks.inheritableHandlers),\n              tags: Array.from(new Set(baseCallbacks.tags.concat(providedCallbacks.tags))),\n              inheritableTags: Array.from(new Set(baseCallbacks.inheritableTags.concat(providedCallbacks.inheritableTags))),\n              metadata: {\n                ...baseCallbacks.metadata,\n                ...providedCallbacks.metadata\n              }\n            });\n          }\n        }\n      } else {\n        const typedKey = key;\n        copy[typedKey] = options[typedKey] ?? copy[typedKey];\n      }\n    }\n  }\n  return copy;\n}\nconst PRIMITIVES = new Set([\"string\", \"number\", \"boolean\"]);\n/**\n * Ensure that a passed config is an object with all required keys present.\n *\n * Note: To make sure async local storage loading works correctly, this\n * should not be called with a default or prepopulated config argument.\n */\nexport function ensureConfig(config) {\n  const loadedConfig = config ?? AsyncLocalStorageProviderSingleton.getInstance().getStore();\n  let empty = {\n    tags: [],\n    metadata: {},\n    callbacks: undefined,\n    recursionLimit: 25,\n    runId: undefined\n  };\n  if (loadedConfig) {\n    empty = {\n      ...empty,\n      ...loadedConfig\n    };\n  }\n  if (loadedConfig?.configurable) {\n    for (const key of Object.keys(loadedConfig.configurable)) {\n      if (PRIMITIVES.has(typeof loadedConfig.configurable[key]) && !empty.metadata?.[key]) {\n        if (!empty.metadata) {\n          empty.metadata = {};\n        }\n        empty.metadata[key] = loadedConfig.configurable[key];\n      }\n    }\n  }\n  return empty;\n}\n/**\n * Helper function that patches runnable configs with updated properties.\n */\nexport function patchConfig(config = {}, {\n  callbacks,\n  maxConcurrency,\n  recursionLimit,\n  runName,\n  configurable,\n  runId\n} = {}) {\n  const newConfig = ensureConfig(config);\n  if (callbacks !== undefined) {\n    /**\n     * If we're replacing callbacks we need to unset runName\n     * since that should apply only to the same run as the original callbacks\n     */\n    delete newConfig.runName;\n    newConfig.callbacks = callbacks;\n  }\n  if (recursionLimit !== undefined) {\n    newConfig.recursionLimit = recursionLimit;\n  }\n  if (maxConcurrency !== undefined) {\n    newConfig.maxConcurrency = maxConcurrency;\n  }\n  if (runName !== undefined) {\n    newConfig.runName = runName;\n  }\n  if (configurable !== undefined) {\n    newConfig.configurable = {\n      ...newConfig.configurable,\n      ...configurable\n    };\n  }\n  if (runId !== undefined) {\n    delete newConfig.runId;\n  }\n  return newConfig;\n}","map":{"version":3,"names":["CallbackManager","ensureHandler","AsyncLocalStorageProviderSingleton","DEFAULT_RECURSION_LIMIT","getCallbackManagerForConfig","config","configure","callbacks","undefined","tags","metadata","mergeConfigs","configs","copy","options","filter","c","key","Object","keys","baseKeys","Set","concat","baseCallbacks","providedCallbacks","Array","isArray","manager","callback","addHandler","_parentRunId","handlers","inheritableHandlers","from","inheritableTags","typedKey","PRIMITIVES","ensureConfig","loadedConfig","getInstance","getStore","empty","recursionLimit","runId","configurable","has","patchConfig","maxConcurrency","runName","newConfig"],"sources":["C:/Users/lucil/Gen-AI-Contest/FrontEnd/kridic-front/node_modules/@langchain/core/dist/runnables/config.js"],"sourcesContent":["import { CallbackManager, ensureHandler, } from \"../callbacks/manager.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nexport const DEFAULT_RECURSION_LIMIT = 25;\nexport async function getCallbackManagerForConfig(config) {\n    return CallbackManager.configure(config?.callbacks, undefined, config?.tags, undefined, config?.metadata);\n}\nexport function mergeConfigs(...configs) {\n    // We do not want to call ensureConfig on the empty state here as this may cause\n    // double loading of callbacks if async local storage is being used.\n    const copy = {};\n    for (const options of configs.filter((c) => !!c)) {\n        for (const key of Object.keys(options)) {\n            if (key === \"metadata\") {\n                copy[key] = { ...copy[key], ...options[key] };\n            }\n            else if (key === \"tags\") {\n                const baseKeys = copy[key] ?? [];\n                copy[key] = [...new Set(baseKeys.concat(options[key] ?? []))];\n            }\n            else if (key === \"configurable\") {\n                copy[key] = { ...copy[key], ...options[key] };\n            }\n            else if (key === \"callbacks\") {\n                const baseCallbacks = copy.callbacks;\n                const providedCallbacks = options.callbacks;\n                // callbacks can be either undefined, Array<handler> or manager\n                // so merging two callbacks values has 6 cases\n                if (Array.isArray(providedCallbacks)) {\n                    if (!baseCallbacks) {\n                        copy.callbacks = providedCallbacks;\n                    }\n                    else if (Array.isArray(baseCallbacks)) {\n                        copy.callbacks = baseCallbacks.concat(providedCallbacks);\n                    }\n                    else {\n                        // baseCallbacks is a manager\n                        const manager = baseCallbacks.copy();\n                        for (const callback of providedCallbacks) {\n                            manager.addHandler(ensureHandler(callback), true);\n                        }\n                        copy.callbacks = manager;\n                    }\n                }\n                else if (providedCallbacks) {\n                    // providedCallbacks is a manager\n                    if (!baseCallbacks) {\n                        copy.callbacks = providedCallbacks;\n                    }\n                    else if (Array.isArray(baseCallbacks)) {\n                        const manager = providedCallbacks.copy();\n                        for (const callback of baseCallbacks) {\n                            manager.addHandler(ensureHandler(callback), true);\n                        }\n                        copy.callbacks = manager;\n                    }\n                    else {\n                        // baseCallbacks is also a manager\n                        copy.callbacks = new CallbackManager(providedCallbacks._parentRunId, {\n                            handlers: baseCallbacks.handlers.concat(providedCallbacks.handlers),\n                            inheritableHandlers: baseCallbacks.inheritableHandlers.concat(providedCallbacks.inheritableHandlers),\n                            tags: Array.from(new Set(baseCallbacks.tags.concat(providedCallbacks.tags))),\n                            inheritableTags: Array.from(new Set(baseCallbacks.inheritableTags.concat(providedCallbacks.inheritableTags))),\n                            metadata: {\n                                ...baseCallbacks.metadata,\n                                ...providedCallbacks.metadata,\n                            },\n                        });\n                    }\n                }\n            }\n            else {\n                const typedKey = key;\n                copy[typedKey] = options[typedKey] ?? copy[typedKey];\n            }\n        }\n    }\n    return copy;\n}\nconst PRIMITIVES = new Set([\"string\", \"number\", \"boolean\"]);\n/**\n * Ensure that a passed config is an object with all required keys present.\n *\n * Note: To make sure async local storage loading works correctly, this\n * should not be called with a default or prepopulated config argument.\n */\nexport function ensureConfig(config) {\n    const loadedConfig = config ?? AsyncLocalStorageProviderSingleton.getInstance().getStore();\n    let empty = {\n        tags: [],\n        metadata: {},\n        callbacks: undefined,\n        recursionLimit: 25,\n        runId: undefined,\n    };\n    if (loadedConfig) {\n        empty = { ...empty, ...loadedConfig };\n    }\n    if (loadedConfig?.configurable) {\n        for (const key of Object.keys(loadedConfig.configurable)) {\n            if (PRIMITIVES.has(typeof loadedConfig.configurable[key]) &&\n                !empty.metadata?.[key]) {\n                if (!empty.metadata) {\n                    empty.metadata = {};\n                }\n                empty.metadata[key] = loadedConfig.configurable[key];\n            }\n        }\n    }\n    return empty;\n}\n/**\n * Helper function that patches runnable configs with updated properties.\n */\nexport function patchConfig(config = {}, { callbacks, maxConcurrency, recursionLimit, runName, configurable, runId, } = {}) {\n    const newConfig = ensureConfig(config);\n    if (callbacks !== undefined) {\n        /**\n         * If we're replacing callbacks we need to unset runName\n         * since that should apply only to the same run as the original callbacks\n         */\n        delete newConfig.runName;\n        newConfig.callbacks = callbacks;\n    }\n    if (recursionLimit !== undefined) {\n        newConfig.recursionLimit = recursionLimit;\n    }\n    if (maxConcurrency !== undefined) {\n        newConfig.maxConcurrency = maxConcurrency;\n    }\n    if (runName !== undefined) {\n        newConfig.runName = runName;\n    }\n    if (configurable !== undefined) {\n        newConfig.configurable = { ...newConfig.configurable, ...configurable };\n    }\n    if (runId !== undefined) {\n        delete newConfig.runId;\n    }\n    return newConfig;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}