{"ast":null,"code":"import { Client } from \"langsmith\";\nimport { getCurrentRunTree } from \"langsmith/singletons/traceable\";\nimport { getEnvironmentVariable, getRuntimeEnvironment } from \"../utils/env.js\";\nimport { BaseTracer } from \"./base.js\";\nexport class LangChainTracer extends BaseTracer {\n  constructor(fields = {}) {\n    super(fields);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"langchain_tracer\"\n    });\n    Object.defineProperty(this, \"projectName\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"exampleId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"client\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    const {\n      exampleId,\n      projectName,\n      client\n    } = fields;\n    this.projectName = projectName ?? getEnvironmentVariable(\"LANGCHAIN_PROJECT\") ?? getEnvironmentVariable(\"LANGCHAIN_SESSION\");\n    this.exampleId = exampleId;\n    this.client = client ?? new Client({});\n    // if we're inside traceable, we can obtain the traceable tree\n    // and populate the run map, which is used to correctly\n    // infer dotted order and execution order\n    const traceableTree = this.getTraceableRunTree();\n    if (traceableTree) {\n      let rootRun = traceableTree;\n      const visited = new Set();\n      while (rootRun.parent_run) {\n        if (visited.has(rootRun.id)) break;\n        visited.add(rootRun.id);\n        if (!rootRun.parent_run) break;\n        rootRun = rootRun.parent_run;\n      }\n      visited.clear();\n      const queue = [rootRun];\n      while (queue.length > 0) {\n        const current = queue.shift();\n        if (!current || visited.has(current.id)) continue;\n        visited.add(current.id);\n        // @ts-expect-error Types of property 'events' are incompatible.\n        this.runMap.set(current.id, current);\n        if (current.child_runs) {\n          queue.push(...current.child_runs);\n        }\n      }\n      this.client = traceableTree.client ?? this.client;\n      this.projectName = traceableTree.project_name ?? this.projectName;\n      this.exampleId = traceableTree.reference_example_id ?? this.exampleId;\n    }\n  }\n  async _convertToCreate(run, example_id = undefined) {\n    return {\n      ...run,\n      extra: {\n        ...run.extra,\n        runtime: await getRuntimeEnvironment()\n      },\n      child_runs: undefined,\n      session_name: this.projectName,\n      reference_example_id: run.parent_run_id ? undefined : example_id\n    };\n  }\n  async persistRun(_run) {}\n  async onRunCreate(run) {\n    const persistedRun = await this._convertToCreate(run, this.exampleId);\n    await this.client.createRun(persistedRun);\n  }\n  async onRunUpdate(run) {\n    const runUpdate = {\n      end_time: run.end_time,\n      error: run.error,\n      outputs: run.outputs,\n      events: run.events,\n      inputs: run.inputs,\n      trace_id: run.trace_id,\n      dotted_order: run.dotted_order,\n      parent_run_id: run.parent_run_id\n    };\n    await this.client.updateRun(run.id, runUpdate);\n  }\n  getRun(id) {\n    return this.runMap.get(id);\n  }\n  getTraceableRunTree() {\n    try {\n      return getCurrentRunTree();\n    } catch {\n      return undefined;\n    }\n  }\n}","map":{"version":3,"names":["Client","getCurrentRunTree","getEnvironmentVariable","getRuntimeEnvironment","BaseTracer","LangChainTracer","constructor","fields","Object","defineProperty","enumerable","configurable","writable","value","exampleId","projectName","client","traceableTree","getTraceableRunTree","rootRun","visited","Set","parent_run","has","id","add","clear","queue","length","current","shift","runMap","set","child_runs","push","project_name","reference_example_id","_convertToCreate","run","example_id","undefined","extra","runtime","session_name","parent_run_id","persistRun","_run","onRunCreate","persistedRun","createRun","onRunUpdate","runUpdate","end_time","error","outputs","events","inputs","trace_id","dotted_order","updateRun","getRun","get"],"sources":["C:/Users/lucil/Gen-AI-Contest/FrontEnd/kridic-front/node_modules/@langchain/core/dist/tracers/tracer_langchain.js"],"sourcesContent":["import { Client } from \"langsmith\";\nimport { getCurrentRunTree } from \"langsmith/singletons/traceable\";\nimport { getEnvironmentVariable, getRuntimeEnvironment } from \"../utils/env.js\";\nimport { BaseTracer } from \"./base.js\";\nexport class LangChainTracer extends BaseTracer {\n    constructor(fields = {}) {\n        super(fields);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"langchain_tracer\"\n        });\n        Object.defineProperty(this, \"projectName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"exampleId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const { exampleId, projectName, client } = fields;\n        this.projectName =\n            projectName ??\n                getEnvironmentVariable(\"LANGCHAIN_PROJECT\") ??\n                getEnvironmentVariable(\"LANGCHAIN_SESSION\");\n        this.exampleId = exampleId;\n        this.client = client ?? new Client({});\n        // if we're inside traceable, we can obtain the traceable tree\n        // and populate the run map, which is used to correctly\n        // infer dotted order and execution order\n        const traceableTree = this.getTraceableRunTree();\n        if (traceableTree) {\n            let rootRun = traceableTree;\n            const visited = new Set();\n            while (rootRun.parent_run) {\n                if (visited.has(rootRun.id))\n                    break;\n                visited.add(rootRun.id);\n                if (!rootRun.parent_run)\n                    break;\n                rootRun = rootRun.parent_run;\n            }\n            visited.clear();\n            const queue = [rootRun];\n            while (queue.length > 0) {\n                const current = queue.shift();\n                if (!current || visited.has(current.id))\n                    continue;\n                visited.add(current.id);\n                // @ts-expect-error Types of property 'events' are incompatible.\n                this.runMap.set(current.id, current);\n                if (current.child_runs) {\n                    queue.push(...current.child_runs);\n                }\n            }\n            this.client = traceableTree.client ?? this.client;\n            this.projectName = traceableTree.project_name ?? this.projectName;\n            this.exampleId = traceableTree.reference_example_id ?? this.exampleId;\n        }\n    }\n    async _convertToCreate(run, example_id = undefined) {\n        return {\n            ...run,\n            extra: {\n                ...run.extra,\n                runtime: await getRuntimeEnvironment(),\n            },\n            child_runs: undefined,\n            session_name: this.projectName,\n            reference_example_id: run.parent_run_id ? undefined : example_id,\n        };\n    }\n    async persistRun(_run) { }\n    async onRunCreate(run) {\n        const persistedRun = await this._convertToCreate(run, this.exampleId);\n        await this.client.createRun(persistedRun);\n    }\n    async onRunUpdate(run) {\n        const runUpdate = {\n            end_time: run.end_time,\n            error: run.error,\n            outputs: run.outputs,\n            events: run.events,\n            inputs: run.inputs,\n            trace_id: run.trace_id,\n            dotted_order: run.dotted_order,\n            parent_run_id: run.parent_run_id,\n        };\n        await this.client.updateRun(run.id, runUpdate);\n    }\n    getRun(id) {\n        return this.runMap.get(id);\n    }\n    getTraceableRunTree() {\n        try {\n            return getCurrentRunTree();\n        }\n        catch {\n            return undefined;\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}