{"ast":null,"code":"import { z } from \"zod\";\nimport pRetry from \"p-retry\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { isTraceableFunction } from \"langsmith/singletons/traceable\";\nimport { CallbackManager } from \"../callbacks/manager.js\";\nimport { LogStreamCallbackHandler, RunLog, RunLogPatch, isLogStreamHandler } from \"../tracers/log_stream.js\";\nimport { EventStreamCallbackHandler, isStreamEventsHandler } from \"../tracers/event_stream.js\";\nimport { Serializable } from \"../load/serializable.js\";\nimport { IterableReadableStream, concat, atee, pipeGeneratorWithSetup, AsyncGeneratorWithSetup } from \"../utils/stream.js\";\nimport { DEFAULT_RECURSION_LIMIT, ensureConfig, getCallbackManagerForConfig, mergeConfigs, patchConfig } from \"./config.js\";\nimport { AsyncCaller } from \"../utils/async_caller.js\";\nimport { RootListenersTracer } from \"../tracers/root_listener.js\";\nimport { _RootEventFilter, isRunnableInterface } from \"./utils.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport { Graph } from \"./graph.js\";\nimport { convertToHttpEventStream } from \"./wrappers.js\";\nimport { consumeAsyncIterableInContext, consumeIteratorInContext, isAsyncIterable, isIterableIterator, isIterator } from \"./iter.js\";\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function _coerceToDict(value, defaultKey) {\n  return value && !Array.isArray(value) &&\n  // eslint-disable-next-line no-instanceof/no-instanceof\n  !(value instanceof Date) && typeof value === \"object\" ? value : {\n    [defaultKey]: value\n  };\n}\n/**\n * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or\n * transformed.\n */\nexport class Runnable extends Serializable {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"lc_runnable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n  }\n  getName(suffix) {\n    const name =\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.name ?? this.constructor.lc_name() ?? this.constructor.name;\n    return suffix ? `${name}${suffix}` : name;\n  }\n  /**\n   * Bind arguments to a Runnable, returning a new Runnable.\n   * @param kwargs\n   * @returns A new RunnableBinding that, when invoked, will apply the bound args.\n   */\n  bind(kwargs) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableBinding({\n      bound: this,\n      kwargs,\n      config: {}\n    });\n  }\n  /**\n   * Return a new Runnable that maps a list of inputs to a list of outputs,\n   * by calling invoke() with each input.\n   */\n  map() {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableEach({\n      bound: this\n    });\n  }\n  /**\n   * Add retry logic to an existing runnable.\n   * @param kwargs\n   * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.\n   */\n  withRetry(fields) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableRetry({\n      bound: this,\n      kwargs: {},\n      config: {},\n      maxAttemptNumber: fields?.stopAfterAttempt,\n      ...fields\n    });\n  }\n  /**\n   * Bind config to a Runnable, returning a new Runnable.\n   * @param config New configuration parameters to attach to the new runnable.\n   * @returns A new RunnableBinding with a config matching what's passed.\n   */\n  withConfig(config) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableBinding({\n      bound: this,\n      config,\n      kwargs: {}\n    });\n  }\n  /**\n   * Create a new runnable from the current one that will try invoking\n   * other passed fallback runnables if the initial invocation fails.\n   * @param fields.fallbacks Other runnables to call if the runnable errors.\n   * @returns A new RunnableWithFallbacks.\n   */\n  withFallbacks(fields) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableWithFallbacks({\n      runnable: this,\n      fallbacks: fields.fallbacks\n    });\n  }\n  _getOptionsList(options, length = 0) {\n    if (Array.isArray(options) && options.length !== length) {\n      throw new Error(`Passed \"options\" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);\n    }\n    if (Array.isArray(options)) {\n      return options.map(ensureConfig);\n    }\n    if (length > 1 && !Array.isArray(options) && options.runId) {\n      console.warn(\"Provided runId will be used only for the first element of the batch.\");\n      const subsequent = Object.fromEntries(Object.entries(options).filter(([key]) => key !== \"runId\"));\n      return Array.from({\n        length\n      }, (_, i) => ensureConfig(i === 0 ? options : subsequent));\n    }\n    return Array.from({\n      length\n    }, () => ensureConfig(options));\n  }\n  async batch(inputs, options, batchOptions) {\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const maxConcurrency = configList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n    const caller = new AsyncCaller({\n      maxConcurrency,\n      onFailedAttempt: e => {\n        throw e;\n      }\n    });\n    const batchCalls = inputs.map((input, i) => caller.call(async () => {\n      try {\n        const result = await this.invoke(input, configList[i]);\n        return result;\n      } catch (e) {\n        if (batchOptions?.returnExceptions) {\n          return e;\n        }\n        throw e;\n      }\n    }));\n    return Promise.all(batchCalls);\n  }\n  /**\n   * Default streaming implementation.\n   * Subclasses should override this method if they support streaming output.\n   * @param input\n   * @param options\n   */\n  async *_streamIterator(input, options) {\n    yield this.invoke(input, options);\n  }\n  /**\n   * Stream output in chunks.\n   * @param input\n   * @param options\n   * @returns A readable stream that is also an iterable.\n   */\n  async stream(input, options) {\n    // Buffer the first streamed chunk to allow for initial errors\n    // to surface immediately.\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this._streamIterator(input, config),\n      config\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n  _separateRunnableConfigFromCallOptions(options) {\n    let runnableConfig;\n    if (options === undefined) {\n      runnableConfig = ensureConfig(options);\n    } else {\n      runnableConfig = ensureConfig({\n        callbacks: options.callbacks,\n        tags: options.tags,\n        metadata: options.metadata,\n        runName: options.runName,\n        configurable: options.configurable,\n        recursionLimit: options.recursionLimit,\n        maxConcurrency: options.maxConcurrency,\n        runId: options.runId\n      });\n    }\n    const callOptions = {\n      ...options\n    };\n    delete callOptions.callbacks;\n    delete callOptions.tags;\n    delete callOptions.metadata;\n    delete callOptions.runName;\n    delete callOptions.configurable;\n    delete callOptions.recursionLimit;\n    delete callOptions.maxConcurrency;\n    delete callOptions.runId;\n    return [runnableConfig, callOptions];\n  }\n  async _callWithConfig(func, input, options) {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, config?.runType, undefined, undefined, config?.runName ?? this.getName());\n    delete config.runId;\n    let output;\n    try {\n      output = await func.call(this, input, config, runManager);\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n    return output;\n  }\n  /**\n   * Internal method that handles batching and configuration for a runnable\n   * It takes a function, input values, and optional configuration, and\n   * returns a promise that resolves to the output values.\n   * @param func The function to be executed for each input value.\n   * @param input The input values to be processed.\n   * @param config Optional configuration for the function execution.\n   * @returns A promise that resolves to the output values.\n   */\n  async _batchWithConfig(func, inputs, options, batchOptions) {\n    const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n    const callbackManagers = await Promise.all(optionsList.map(getCallbackManagerForConfig));\n    const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n      const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), optionsList[i].runId, optionsList[i].runType, undefined, undefined, optionsList[i].runName ?? this.getName());\n      delete optionsList[i].runId;\n      return handleStartRes;\n    }));\n    let outputs;\n    try {\n      outputs = await func.call(this, inputs, optionsList, runManagers, batchOptions);\n    } catch (e) {\n      await Promise.all(runManagers.map(runManager => runManager?.handleChainError(e)));\n      throw e;\n    }\n    await Promise.all(runManagers.map(runManager => runManager?.handleChainEnd(_coerceToDict(outputs, \"output\"))));\n    return outputs;\n  }\n  /**\n   * Helper method to transform an Iterator of Input values into an Iterator of\n   * Output values, with callbacks.\n   * Use this to implement `stream()` or `transform()` in Runnable subclasses.\n   */\n  async *_transformStreamWithConfig(inputGenerator, transformer, options) {\n    let finalInput;\n    let finalInputSupported = true;\n    let finalOutput;\n    let finalOutputSupported = true;\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    async function* wrapInputForTracing() {\n      for await (const chunk of inputGenerator) {\n        if (finalInputSupported) {\n          if (finalInput === undefined) {\n            finalInput = chunk;\n          } else {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              finalInput = concat(finalInput, chunk);\n            } catch {\n              finalInput = undefined;\n              finalInputSupported = false;\n            }\n          }\n        }\n        yield chunk;\n      }\n    }\n    let runManager;\n    try {\n      const pipe = await pipeGeneratorWithSetup(transformer.bind(this), wrapInputForTracing(), async () => callbackManager_?.handleChainStart(this.toJSON(), {\n        input: \"\"\n      }, config.runId, config.runType, undefined, undefined, config.runName ?? this.getName()), config);\n      delete config.runId;\n      runManager = pipe.setup;\n      const streamEventsHandler = runManager?.handlers.find(isStreamEventsHandler);\n      let iterator = pipe.output;\n      if (streamEventsHandler !== undefined && runManager !== undefined) {\n        iterator = streamEventsHandler.tapOutputIterable(runManager.runId, iterator);\n      }\n      const streamLogHandler = runManager?.handlers.find(isLogStreamHandler);\n      if (streamLogHandler !== undefined && runManager !== undefined) {\n        iterator = streamLogHandler.tapOutputIterable(runManager.runId, iterator);\n      }\n      for await (const chunk of iterator) {\n        yield chunk;\n        if (finalOutputSupported) {\n          if (finalOutput === undefined) {\n            finalOutput = chunk;\n          } else {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              finalOutput = concat(finalOutput, chunk);\n            } catch {\n              finalOutput = undefined;\n              finalOutputSupported = false;\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e, undefined, undefined, undefined, {\n        inputs: _coerceToDict(finalInput, \"input\")\n      });\n      throw e;\n    }\n    await runManager?.handleChainEnd(finalOutput ?? {}, undefined, undefined, undefined, {\n      inputs: _coerceToDict(finalInput, \"input\")\n    });\n  }\n  getGraph(_) {\n    const graph = new Graph();\n    // TODO: Add input schema for runnables\n    const inputNode = graph.addNode({\n      name: `${this.getName()}Input`,\n      schema: z.any()\n    });\n    const runnableNode = graph.addNode(this);\n    // TODO: Add output schemas for runnables\n    const outputNode = graph.addNode({\n      name: `${this.getName()}Output`,\n      schema: z.any()\n    });\n    graph.addEdge(inputNode, runnableNode);\n    graph.addEdge(runnableNode, outputNode);\n    return graph;\n  }\n  /**\n   * Create a new runnable sequence that runs each individual runnable in series,\n   * piping the output of one runnable into another runnable or runnable-like.\n   * @param coerceable A runnable, function, or object whose values are functions or runnables.\n   * @returns A new runnable sequence.\n   */\n  pipe(coerceable) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableSequence({\n      first: this,\n      last: _coerceToRunnable(coerceable)\n    });\n  }\n  /**\n   * Pick keys from the dict output of this runnable. Returns a new runnable.\n   */\n  pick(keys) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return this.pipe(new RunnablePick(keys));\n  }\n  /**\n   * Assigns new fields to the dict output of this runnable. Returns a new runnable.\n   */\n  assign(mapping) {\n    return this.pipe(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    new RunnableAssign(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    new RunnableMap({\n      steps: mapping\n    })));\n  }\n  /**\n   * Default implementation of transform, which buffers input and then calls stream.\n   * Subclasses should override this method if they can start producing output while\n   * input is still being generated.\n   * @param generator\n   * @param options\n   */\n  async *transform(generator, options) {\n    let finalChunk;\n    for await (const chunk of generator) {\n      if (finalChunk === undefined) {\n        finalChunk = chunk;\n      } else {\n        // Make a best effort to gather, for any type that supports concat.\n        // This method should throw an error if gathering fails.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        finalChunk = concat(finalChunk, chunk);\n      }\n    }\n    yield* this._streamIterator(finalChunk, ensureConfig(options));\n  }\n  /**\n   * Stream all output from a runnable, as reported to the callback system.\n   * This includes all inner runs of LLMs, Retrievers, Tools, etc.\n   * Output is streamed as Log objects, which include a list of\n   * jsonpatch ops that describe how the state of the run has changed in each\n   * step, and the final state of the run.\n   * The jsonpatch ops can be applied in order to construct state.\n   * @param input\n   * @param options\n   * @param streamOptions\n   */\n  async *streamLog(input, options, streamOptions) {\n    const logStreamCallbackHandler = new LogStreamCallbackHandler({\n      ...streamOptions,\n      autoClose: false,\n      _schemaFormat: \"original\"\n    });\n    const config = ensureConfig(options);\n    yield* this._streamLog(input, logStreamCallbackHandler, config);\n  }\n  async *_streamLog(input, logStreamCallbackHandler, config) {\n    const {\n      callbacks\n    } = config;\n    if (callbacks === undefined) {\n      // eslint-disable-next-line no-param-reassign\n      config.callbacks = [logStreamCallbackHandler];\n    } else if (Array.isArray(callbacks)) {\n      // eslint-disable-next-line no-param-reassign\n      config.callbacks = callbacks.concat([logStreamCallbackHandler]);\n    } else {\n      const copiedCallbacks = callbacks.copy();\n      copiedCallbacks.inheritableHandlers.push(logStreamCallbackHandler);\n      // eslint-disable-next-line no-param-reassign\n      config.callbacks = copiedCallbacks;\n    }\n    const runnableStreamPromise = this.stream(input, config);\n    async function consumeRunnableStream() {\n      try {\n        const runnableStream = await runnableStreamPromise;\n        for await (const chunk of runnableStream) {\n          const patch = new RunLogPatch({\n            ops: [{\n              op: \"add\",\n              path: \"/streamed_output/-\",\n              value: chunk\n            }]\n          });\n          await logStreamCallbackHandler.writer.write(patch);\n        }\n      } finally {\n        await logStreamCallbackHandler.writer.close();\n      }\n    }\n    const runnableStreamConsumePromise = consumeRunnableStream();\n    try {\n      for await (const log of logStreamCallbackHandler) {\n        yield log;\n      }\n    } finally {\n      await runnableStreamConsumePromise;\n    }\n  }\n  streamEvents(input, options, streamOptions) {\n    let stream;\n    if (options.version === \"v1\") {\n      stream = this._streamEventsV1(input, options, streamOptions);\n    } else if (options.version === \"v2\") {\n      stream = this._streamEventsV2(input, options, streamOptions);\n    } else {\n      throw new Error(`Only versions \"v1\" and \"v2\" of the schema are currently supported.`);\n    }\n    if (options.encoding === \"text/event-stream\") {\n      return convertToHttpEventStream(stream);\n    } else {\n      return IterableReadableStream.fromAsyncGenerator(stream);\n    }\n  }\n  async *_streamEventsV2(input, options, streamOptions) {\n    const eventStreamer = new EventStreamCallbackHandler({\n      ...streamOptions,\n      autoClose: false\n    });\n    const config = ensureConfig(options);\n    const runId = config.runId ?? uuidv4();\n    config.runId = runId;\n    const callbacks = config.callbacks;\n    if (callbacks === undefined) {\n      config.callbacks = [eventStreamer];\n    } else if (Array.isArray(callbacks)) {\n      config.callbacks = callbacks.concat(eventStreamer);\n    } else {\n      const copiedCallbacks = callbacks.copy();\n      copiedCallbacks.inheritableHandlers.push(eventStreamer);\n      // eslint-disable-next-line no-param-reassign\n      config.callbacks = copiedCallbacks;\n    }\n    // Call the runnable in streaming mode,\n    // add each chunk to the output stream\n    const outerThis = this;\n    async function consumeRunnableStream() {\n      try {\n        const runnableStream = await outerThis.stream(input, config);\n        const tappedStream = eventStreamer.tapOutputIterable(runId, runnableStream);\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        for await (const _ of tappedStream) {\n          // Just iterate so that the callback handler picks up events\n        }\n      } finally {\n        await eventStreamer.finish();\n      }\n    }\n    const runnableStreamConsumePromise = consumeRunnableStream();\n    let firstEventSent = false;\n    let firstEventRunId;\n    try {\n      for await (const event of eventStreamer) {\n        // This is a work-around an issue where the inputs into the\n        // chain are not available until the entire input is consumed.\n        // As a temporary solution, we'll modify the input to be the input\n        // that was passed into the chain.\n        if (!firstEventSent) {\n          event.data.input = input;\n          firstEventSent = true;\n          firstEventRunId = event.run_id;\n          yield event;\n          continue;\n        }\n        if (event.run_id === firstEventRunId && event.event.endsWith(\"_end\")) {\n          // If it's the end event corresponding to the root runnable\n          // we dont include the input in the event since it's guaranteed\n          // to be included in the first event.\n          if (event.data?.input) {\n            delete event.data.input;\n          }\n        }\n        yield event;\n      }\n    } finally {\n      await runnableStreamConsumePromise;\n    }\n  }\n  async *_streamEventsV1(input, options, streamOptions) {\n    let runLog;\n    let hasEncounteredStartEvent = false;\n    const config = ensureConfig(options);\n    const rootTags = config.tags ?? [];\n    const rootMetadata = config.metadata ?? {};\n    const rootName = config.runName ?? this.getName();\n    const logStreamCallbackHandler = new LogStreamCallbackHandler({\n      ...streamOptions,\n      autoClose: false,\n      _schemaFormat: \"streaming_events\"\n    });\n    const rootEventFilter = new _RootEventFilter({\n      ...streamOptions\n    });\n    const logStream = this._streamLog(input, logStreamCallbackHandler, config);\n    for await (const log of logStream) {\n      if (!runLog) {\n        runLog = RunLog.fromRunLogPatch(log);\n      } else {\n        runLog = runLog.concat(log);\n      }\n      if (runLog.state === undefined) {\n        throw new Error(`Internal error: \"streamEvents\" state is missing. Please open a bug report.`);\n      }\n      // Yield the start event for the root runnable if it hasn't been seen.\n      // The root run is never filtered out\n      if (!hasEncounteredStartEvent) {\n        hasEncounteredStartEvent = true;\n        const state = {\n          ...runLog.state\n        };\n        const event = {\n          run_id: state.id,\n          event: `on_${state.type}_start`,\n          name: rootName,\n          tags: rootTags,\n          metadata: rootMetadata,\n          data: {\n            input\n          }\n        };\n        if (rootEventFilter.includeEvent(event, state.type)) {\n          yield event;\n        }\n      }\n      const paths = log.ops.filter(op => op.path.startsWith(\"/logs/\")).map(op => op.path.split(\"/\")[2]);\n      const dedupedPaths = [...new Set(paths)];\n      for (const path of dedupedPaths) {\n        let eventType;\n        let data = {};\n        const logEntry = runLog.state.logs[path];\n        if (logEntry.end_time === undefined) {\n          if (logEntry.streamed_output.length > 0) {\n            eventType = \"stream\";\n          } else {\n            eventType = \"start\";\n          }\n        } else {\n          eventType = \"end\";\n        }\n        if (eventType === \"start\") {\n          // Include the inputs with the start event if they are available.\n          // Usually they will NOT be available for components that operate\n          // on streams, since those components stream the input and\n          // don't know its final value until the end of the stream.\n          if (logEntry.inputs !== undefined) {\n            data.input = logEntry.inputs;\n          }\n        } else if (eventType === \"end\") {\n          if (logEntry.inputs !== undefined) {\n            data.input = logEntry.inputs;\n          }\n          data.output = logEntry.final_output;\n        } else if (eventType === \"stream\") {\n          const chunkCount = logEntry.streamed_output.length;\n          if (chunkCount !== 1) {\n            throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${logEntry.name}\"`);\n          }\n          data = {\n            chunk: logEntry.streamed_output[0]\n          };\n          // Clean up the stream, we don't need it anymore.\n          // And this avoids duplicates as well!\n          logEntry.streamed_output = [];\n        }\n        yield {\n          event: `on_${logEntry.type}_${eventType}`,\n          name: logEntry.name,\n          run_id: logEntry.id,\n          tags: logEntry.tags,\n          metadata: logEntry.metadata,\n          data\n        };\n      }\n      // Finally, we take care of the streaming output from the root chain\n      // if there is any.\n      const {\n        state\n      } = runLog;\n      if (state.streamed_output.length > 0) {\n        const chunkCount = state.streamed_output.length;\n        if (chunkCount !== 1) {\n          throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${state.name}\"`);\n        }\n        const data = {\n          chunk: state.streamed_output[0]\n        };\n        // Clean up the stream, we don't need it anymore.\n        state.streamed_output = [];\n        const event = {\n          event: `on_${state.type}_stream`,\n          run_id: state.id,\n          tags: rootTags,\n          metadata: rootMetadata,\n          name: rootName,\n          data\n        };\n        if (rootEventFilter.includeEvent(event, state.type)) {\n          yield event;\n        }\n      }\n    }\n    const state = runLog?.state;\n    if (state !== undefined) {\n      // Finally, yield the end event for the root runnable.\n      const event = {\n        event: `on_${state.type}_end`,\n        name: rootName,\n        run_id: state.id,\n        tags: rootTags,\n        metadata: rootMetadata,\n        data: {\n          output: state.final_output\n        }\n      };\n      if (rootEventFilter.includeEvent(event, state.type)) yield event;\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isRunnable(thing) {\n    return isRunnableInterface(thing);\n  }\n  /**\n   * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n   * The Run object contains information about the run, including its id,\n   * type, input, output, error, startTime, endTime, and any tags or metadata\n   * added to the run.\n   *\n   * @param {Object} params - The object containing the callback functions.\n   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n   */\n  withListeners({\n    onStart,\n    onEnd,\n    onError\n  }) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableBinding({\n      bound: this,\n      config: {},\n      configFactories: [config => ({\n        callbacks: [new RootListenersTracer({\n          config,\n          onStart,\n          onEnd,\n          onError\n        })]\n      })]\n    });\n  }\n}\n/**\n * A runnable that delegates calls to another runnable with a set of kwargs.\n */\nexport class RunnableBinding extends Runnable {\n  static lc_name() {\n    return \"RunnableBinding\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"bound\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"config\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"kwargs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"configFactories\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.bound = fields.bound;\n    this.kwargs = fields.kwargs;\n    this.config = fields.config;\n    this.configFactories = fields.configFactories;\n  }\n  getName(suffix) {\n    return this.bound.getName(suffix);\n  }\n  async _mergeConfig(...options) {\n    const config = mergeConfigs(this.config, ...options);\n    return mergeConfigs(config, ...(this.configFactories ? await Promise.all(this.configFactories.map(async configFactory => await configFactory(config))) : []));\n  }\n  bind(kwargs) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return new this.constructor({\n      bound: this.bound,\n      kwargs: {\n        ...this.kwargs,\n        ...kwargs\n      },\n      config: this.config\n    });\n  }\n  withConfig(config) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return new this.constructor({\n      bound: this.bound,\n      kwargs: this.kwargs,\n      config: {\n        ...this.config,\n        ...config\n      }\n    });\n  }\n  withRetry(fields) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return new this.constructor({\n      bound: this.bound.withRetry(fields),\n      kwargs: this.kwargs,\n      config: this.config\n    });\n  }\n  async invoke(input, options) {\n    return this.bound.invoke(input, await this._mergeConfig(ensureConfig(options), this.kwargs));\n  }\n  async batch(inputs, options, batchOptions) {\n    const mergedOptions = Array.isArray(options) ? await Promise.all(options.map(async individualOption => this._mergeConfig(ensureConfig(individualOption), this.kwargs))) : await this._mergeConfig(ensureConfig(options), this.kwargs);\n    return this.bound.batch(inputs, mergedOptions, batchOptions);\n  }\n  async *_streamIterator(input, options) {\n    yield* this.bound._streamIterator(input, await this._mergeConfig(ensureConfig(options), this.kwargs));\n  }\n  async stream(input, options) {\n    return this.bound.stream(input, await this._mergeConfig(ensureConfig(options), this.kwargs));\n  }\n  async *transform(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  generator, options) {\n    yield* this.bound.transform(generator, await this._mergeConfig(ensureConfig(options), this.kwargs));\n  }\n  streamEvents(input, options, streamOptions) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const outerThis = this;\n    const generator = async function* () {\n      yield* outerThis.bound.streamEvents(input, {\n        ...(await outerThis._mergeConfig(ensureConfig(options), outerThis.kwargs)),\n        version: options.version\n      }, streamOptions);\n    };\n    return IterableReadableStream.fromAsyncGenerator(generator());\n  }\n  static isRunnableBinding(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  thing\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    return thing.bound && Runnable.isRunnable(thing.bound);\n  }\n  /**\n   * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n   * The Run object contains information about the run, including its id,\n   * type, input, output, error, startTime, endTime, and any tags or metadata\n   * added to the run.\n   *\n   * @param {Object} params - The object containing the callback functions.\n   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n   */\n  withListeners({\n    onStart,\n    onEnd,\n    onError\n  }) {\n    return new RunnableBinding({\n      bound: this.bound,\n      kwargs: this.kwargs,\n      config: this.config,\n      configFactories: [config => ({\n        callbacks: [new RootListenersTracer({\n          config,\n          onStart,\n          onEnd,\n          onError\n        })]\n      })]\n    });\n  }\n}\n/**\n * A runnable that delegates calls to another runnable\n * with each element of the input sequence.\n */\nexport class RunnableEach extends Runnable {\n  static lc_name() {\n    return \"RunnableEach\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"bound\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.bound = fields.bound;\n  }\n  /**\n   * Binds the runnable with the specified arguments.\n   * @param kwargs The arguments to bind the runnable with.\n   * @returns A new instance of the `RunnableEach` class that is bound with the specified arguments.\n   */\n  bind(kwargs) {\n    return new RunnableEach({\n      bound: this.bound.bind(kwargs)\n    });\n  }\n  /**\n   * Invokes the runnable with the specified input and configuration.\n   * @param input The input to invoke the runnable with.\n   * @param config The configuration to invoke the runnable with.\n   * @returns A promise that resolves to the output of the runnable.\n   */\n  async invoke(inputs, config) {\n    return this._callWithConfig(this._invoke, inputs, config);\n  }\n  /**\n   * A helper method that is used to invoke the runnable with the specified input and configuration.\n   * @param input The input to invoke the runnable with.\n   * @param config The configuration to invoke the runnable with.\n   * @returns A promise that resolves to the output of the runnable.\n   */\n  async _invoke(inputs, config, runManager) {\n    return this.bound.batch(inputs, patchConfig(config, {\n      callbacks: runManager?.getChild()\n    }));\n  }\n  /**\n   * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n   * The Run object contains information about the run, including its id,\n   * type, input, output, error, startTime, endTime, and any tags or metadata\n   * added to the run.\n   *\n   * @param {Object} params - The object containing the callback functions.\n   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n   */\n  withListeners({\n    onStart,\n    onEnd,\n    onError\n  }) {\n    return new RunnableEach({\n      bound: this.bound.withListeners({\n        onStart,\n        onEnd,\n        onError\n      })\n    });\n  }\n}\n/**\n * Base class for runnables that can be retried a\n * specified number of times.\n */\nexport class RunnableRetry extends RunnableBinding {\n  static lc_name() {\n    return \"RunnableRetry\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"maxAttemptNumber\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 3\n    });\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Object.defineProperty(this, \"onFailedAttempt\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: () => {}\n    });\n    this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;\n    this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;\n  }\n  _patchConfigForRetry(attempt, config, runManager) {\n    const tag = attempt > 1 ? `retry:attempt:${attempt}` : undefined;\n    return patchConfig(config, {\n      callbacks: runManager?.getChild(tag)\n    });\n  }\n  async _invoke(input, config, runManager) {\n    return pRetry(attemptNumber => super.invoke(input, this._patchConfigForRetry(attemptNumber, config, runManager)), {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onFailedAttempt: error => this.onFailedAttempt(error, input),\n      retries: Math.max(this.maxAttemptNumber - 1, 0),\n      randomize: true\n    });\n  }\n  /**\n   * Method that invokes the runnable with the specified input, run manager,\n   * and config. It handles the retry logic by catching any errors and\n   * recursively invoking itself with the updated config for the next retry\n   * attempt.\n   * @param input The input for the runnable.\n   * @param runManager The run manager for the runnable.\n   * @param config The config for the runnable.\n   * @returns A promise that resolves to the output of the runnable.\n   */\n  async invoke(input, config) {\n    return this._callWithConfig(this._invoke, input, config);\n  }\n  async _batch(inputs, configs, runManagers, batchOptions) {\n    const resultsMap = {};\n    try {\n      await pRetry(async attemptNumber => {\n        const remainingIndexes = inputs.map((_, i) => i).filter(i => resultsMap[i.toString()] === undefined ||\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        resultsMap[i.toString()] instanceof Error);\n        const remainingInputs = remainingIndexes.map(i => inputs[i]);\n        const patchedConfigs = remainingIndexes.map(i => this._patchConfigForRetry(attemptNumber, configs?.[i], runManagers?.[i]));\n        const results = await super.batch(remainingInputs, patchedConfigs, {\n          ...batchOptions,\n          returnExceptions: true\n        });\n        let firstException;\n        for (let i = 0; i < results.length; i += 1) {\n          const result = results[i];\n          const resultMapIndex = remainingIndexes[i];\n          // eslint-disable-next-line no-instanceof/no-instanceof\n          if (result instanceof Error) {\n            if (firstException === undefined) {\n              firstException = result;\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              firstException.input = remainingInputs[i];\n            }\n          }\n          resultsMap[resultMapIndex.toString()] = result;\n        }\n        if (firstException) {\n          throw firstException;\n        }\n        return results;\n      }, {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        onFailedAttempt: error => this.onFailedAttempt(error, error.input),\n        retries: Math.max(this.maxAttemptNumber - 1, 0),\n        randomize: true\n      });\n    } catch (e) {\n      if (batchOptions?.returnExceptions !== true) {\n        throw e;\n      }\n    }\n    return Object.keys(resultsMap).sort((a, b) => parseInt(a, 10) - parseInt(b, 10)).map(key => resultsMap[parseInt(key, 10)]);\n  }\n  async batch(inputs, options, batchOptions) {\n    return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);\n  }\n}\n/**\n * A sequence of runnables, where the output of each is the input of the next.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n * const chain = RunnableSequence.from([promptTemplate, new ChatOpenAI({})]);\n * const result = await chain.invoke({ topic: \"bears\" });\n * ```\n */\nexport class RunnableSequence extends Runnable {\n  static lc_name() {\n    return \"RunnableSequence\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"first\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"middle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Object.defineProperty(this, \"last\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    this.first = fields.first;\n    this.middle = fields.middle ?? this.middle;\n    this.last = fields.last;\n    this.name = fields.name;\n  }\n  get steps() {\n    return [this.first, ...this.middle, this.last];\n  }\n  async invoke(input, options) {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, undefined, undefined, undefined, config?.runName);\n    delete config.runId;\n    let nextStepInput = input;\n    let finalOutput;\n    try {\n      const initialSteps = [this.first, ...this.middle];\n      for (let i = 0; i < initialSteps.length; i += 1) {\n        const step = initialSteps[i];\n        nextStepInput = await step.invoke(nextStepInput, patchConfig(config, {\n          callbacks: runManager?.getChild(`seq:step:${i + 1}`)\n        }));\n      }\n      // TypeScript can't detect that the last output of the sequence returns RunOutput, so call it out of the loop here\n      finalOutput = await this.last.invoke(nextStepInput, patchConfig(config, {\n        callbacks: runManager?.getChild(`seq:step:${this.steps.length}`)\n      }));\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n    return finalOutput;\n  }\n  async batch(inputs, options, batchOptions) {\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const callbackManagers = await Promise.all(configList.map(getCallbackManagerForConfig));\n    const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n      const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n      delete configList[i].runId;\n      return handleStartRes;\n    }));\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let nextStepInputs = inputs;\n    try {\n      for (let i = 0; i < this.steps.length; i += 1) {\n        const step = this.steps[i];\n        nextStepInputs = await step.batch(nextStepInputs, runManagers.map((runManager, j) => {\n          const childRunManager = runManager?.getChild(`seq:step:${i + 1}`);\n          return patchConfig(configList[j], {\n            callbacks: childRunManager\n          });\n        }), batchOptions);\n      }\n    } catch (e) {\n      await Promise.all(runManagers.map(runManager => runManager?.handleChainError(e)));\n      throw e;\n    }\n    await Promise.all(runManagers.map(runManager => runManager?.handleChainEnd(_coerceToDict(nextStepInputs, \"output\"))));\n    return nextStepInputs;\n  }\n  async *_streamIterator(input, options) {\n    const callbackManager_ = await getCallbackManagerForConfig(options);\n    const {\n      runId,\n      ...otherOptions\n    } = options ?? {};\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherOptions?.runName);\n    const steps = [this.first, ...this.middle, this.last];\n    let concatSupported = true;\n    let finalOutput;\n    async function* inputGenerator() {\n      yield input;\n    }\n    try {\n      let finalGenerator = steps[0].transform(inputGenerator(), patchConfig(otherOptions, {\n        callbacks: runManager?.getChild(`seq:step:1`)\n      }));\n      for (let i = 1; i < steps.length; i += 1) {\n        const step = steps[i];\n        finalGenerator = await step.transform(finalGenerator, patchConfig(otherOptions, {\n          callbacks: runManager?.getChild(`seq:step:${i + 1}`)\n        }));\n      }\n      for await (const chunk of finalGenerator) {\n        yield chunk;\n        if (concatSupported) {\n          if (finalOutput === undefined) {\n            finalOutput = chunk;\n          } else {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              finalOutput = concat(finalOutput, chunk);\n            } catch (e) {\n              finalOutput = undefined;\n              concatSupported = false;\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n  }\n  getGraph(config) {\n    const graph = new Graph();\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let currentLastNode = null;\n    this.steps.forEach((step, index) => {\n      const stepGraph = step.getGraph(config);\n      if (index !== 0) {\n        stepGraph.trimFirstNode();\n      }\n      if (index !== this.steps.length - 1) {\n        stepGraph.trimLastNode();\n      }\n      graph.extend(stepGraph);\n      const stepFirstNode = stepGraph.firstNode();\n      if (!stepFirstNode) {\n        throw new Error(`Runnable ${step} has no first node`);\n      }\n      if (currentLastNode) {\n        graph.addEdge(currentLastNode, stepFirstNode);\n      }\n      currentLastNode = stepGraph.lastNode();\n    });\n    return graph;\n  }\n  pipe(coerceable) {\n    if (RunnableSequence.isRunnableSequence(coerceable)) {\n      return new RunnableSequence({\n        first: this.first,\n        middle: this.middle.concat([this.last, coerceable.first, ...coerceable.middle]),\n        last: coerceable.last,\n        name: this.name ?? coerceable.name\n      });\n    } else {\n      return new RunnableSequence({\n        first: this.first,\n        middle: [...this.middle, this.last],\n        last: _coerceToRunnable(coerceable),\n        name: this.name\n      });\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isRunnableSequence(thing) {\n    return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static from([first, ...runnables], name) {\n    return new RunnableSequence({\n      first: _coerceToRunnable(first),\n      middle: runnables.slice(0, -1).map(_coerceToRunnable),\n      last: _coerceToRunnable(runnables[runnables.length - 1]),\n      name\n    });\n  }\n}\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * const mapChain = RunnableMap.from({\n *   joke: PromptTemplate.fromTemplate(\"Tell me a joke about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n *   poem: PromptTemplate.fromTemplate(\"write a 2-line poem about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n * });\n * const result = await mapChain.invoke({ topic: \"bear\" });\n * ```\n */\nexport class RunnableMap extends Runnable {\n  static lc_name() {\n    return \"RunnableMap\";\n  }\n  getStepsKeys() {\n    return Object.keys(this.steps);\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"steps\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.steps = {};\n    for (const [key, value] of Object.entries(fields.steps)) {\n      this.steps[key] = _coerceToRunnable(value);\n    }\n  }\n  static from(steps) {\n    return new RunnableMap({\n      steps\n    });\n  }\n  async invoke(input, options) {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), {\n      input\n    }, config.runId, undefined, undefined, undefined, config?.runName);\n    delete config.runId;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const output = {};\n    try {\n      await Promise.all(Object.entries(this.steps).map(async ([key, runnable]) => {\n        output[key] = await runnable.invoke(input, patchConfig(config, {\n          callbacks: runManager?.getChild(`map:key:${key}`)\n        }));\n      }));\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(output);\n    return output;\n  }\n  async *_transform(generator, runManager, options) {\n    // shallow copy steps to ignore changes while iterating\n    const steps = {\n      ...this.steps\n    };\n    // each step gets a copy of the input iterator\n    const inputCopies = atee(generator, Object.keys(steps).length);\n    // start the first iteration of each output iterator\n    const tasks = new Map(Object.entries(steps).map(([key, runnable], i) => {\n      const gen = runnable.transform(inputCopies[i], patchConfig(options, {\n        callbacks: runManager?.getChild(`map:key:${key}`)\n      }));\n      return [key, gen.next().then(result => ({\n        key,\n        gen,\n        result\n      }))];\n    }));\n    // yield chunks as they become available,\n    // starting new iterations as needed,\n    // until all iterators are done\n    while (tasks.size) {\n      const {\n        key,\n        result,\n        gen\n      } = await Promise.race(tasks.values());\n      tasks.delete(key);\n      if (!result.done) {\n        yield {\n          [key]: result.value\n        };\n        tasks.set(key, gen.next().then(result => ({\n          key,\n          gen,\n          result\n        })));\n      }\n    }\n  }\n  transform(generator, options) {\n    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n  }\n  async stream(input, options) {\n    async function* generator() {\n      yield input;\n    }\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this.transform(generator(), config),\n      config\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\n/**\n * A runnable that wraps a traced LangSmith function.\n */\nexport class RunnableTraceable extends Runnable {\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"func\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    if (!isTraceableFunction(fields.func)) {\n      throw new Error(\"RunnableTraceable requires a function that is wrapped in traceable higher-order function\");\n    }\n    this.func = fields.func;\n  }\n  async invoke(input, options) {\n    const [config] = this._getOptionsList(options ?? {}, 1);\n    const callbacks = await getCallbackManagerForConfig(config);\n    return await this.func(patchConfig(config, {\n      callbacks\n    }), input);\n  }\n  async *_streamIterator(input, options) {\n    const result = await this.invoke(input, options);\n    if (isAsyncIterable(result)) {\n      for await (const item of result) {\n        yield item;\n      }\n      return;\n    }\n    if (isIterator(result)) {\n      while (true) {\n        const state = result.next();\n        if (state.done) break;\n        yield state.value;\n      }\n      return;\n    }\n    yield result;\n  }\n  static from(func) {\n    return new RunnableTraceable({\n      func\n    });\n  }\n}\nfunction assertNonTraceableFunction(func) {\n  if (isTraceableFunction(func)) {\n    throw new Error(\"RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.\");\n  }\n}\n/**\n * A runnable that runs a callable.\n */\nexport class RunnableLambda extends Runnable {\n  static lc_name() {\n    return \"RunnableLambda\";\n  }\n  constructor(fields) {\n    if (isTraceableFunction(fields.func)) {\n      // eslint-disable-next-line no-constructor-return\n      return RunnableTraceable.from(fields.func);\n    }\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"func\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    assertNonTraceableFunction(fields.func);\n    this.func = fields.func;\n  }\n  static from(func) {\n    return new RunnableLambda({\n      func\n    });\n  }\n  async _invoke(input, config, runManager) {\n    return new Promise((resolve, reject) => {\n      const childConfig = patchConfig(config, {\n        callbacks: runManager?.getChild(),\n        recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1\n      });\n      void AsyncLocalStorageProviderSingleton.getInstance().run(childConfig, async () => {\n        try {\n          let output = await this.func(input, {\n            ...childConfig,\n            config: childConfig\n          });\n          if (output && Runnable.isRunnable(output)) {\n            if (config?.recursionLimit === 0) {\n              throw new Error(\"Recursion limit reached.\");\n            }\n            output = await output.invoke(input, {\n              ...childConfig,\n              recursionLimit: (childConfig.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1\n            });\n          } else if (isAsyncIterable(output)) {\n            let finalOutput;\n            for await (const chunk of consumeAsyncIterableInContext(childConfig, output)) {\n              if (finalOutput === undefined) {\n                finalOutput = chunk;\n              } else {\n                // Make a best effort to gather, for any type that supports concat.\n                try {\n                  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                  finalOutput = concat(finalOutput, chunk);\n                } catch (e) {\n                  finalOutput = chunk;\n                }\n              }\n            }\n            output = finalOutput;\n          } else if (isIterableIterator(output)) {\n            let finalOutput;\n            for (const chunk of consumeIteratorInContext(childConfig, output)) {\n              if (finalOutput === undefined) {\n                finalOutput = chunk;\n              } else {\n                // Make a best effort to gather, for any type that supports concat.\n                try {\n                  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                  finalOutput = concat(finalOutput, chunk);\n                } catch (e) {\n                  finalOutput = chunk;\n                }\n              }\n            }\n            output = finalOutput;\n          }\n          resolve(output);\n        } catch (e) {\n          reject(e);\n        }\n      });\n    });\n  }\n  async invoke(input, options) {\n    return this._callWithConfig(this._invoke, input, options);\n  }\n  async *_transform(generator, runManager, config) {\n    let finalChunk;\n    for await (const chunk of generator) {\n      if (finalChunk === undefined) {\n        finalChunk = chunk;\n      } else {\n        // Make a best effort to gather, for any type that supports concat.\n        try {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          finalChunk = concat(finalChunk, chunk);\n        } catch (e) {\n          finalChunk = chunk;\n        }\n      }\n    }\n    const output = await new Promise((resolve, reject) => {\n      void AsyncLocalStorageProviderSingleton.getInstance().run(config, async () => {\n        try {\n          const res = await this.func(finalChunk, {\n            ...config,\n            config\n          });\n          resolve(res);\n        } catch (e) {\n          reject(e);\n        }\n      });\n    });\n    if (output && Runnable.isRunnable(output)) {\n      if (config?.recursionLimit === 0) {\n        throw new Error(\"Recursion limit reached.\");\n      }\n      const stream = await output.stream(finalChunk, patchConfig(config, {\n        callbacks: runManager?.getChild(),\n        recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1\n      }));\n      for await (const chunk of stream) {\n        yield chunk;\n      }\n    } else if (isAsyncIterable(output)) {\n      for await (const chunk of consumeAsyncIterableInContext(config, output)) {\n        yield chunk;\n      }\n    } else if (isIterableIterator(output)) {\n      for (const chunk of consumeIteratorInContext(config, output)) {\n        yield chunk;\n      }\n    } else {\n      yield output;\n    }\n  }\n  transform(generator, options) {\n    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n  }\n  async stream(input, options) {\n    async function* generator() {\n      yield input;\n    }\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this.transform(generator(), config),\n      config\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\nexport class RunnableParallel extends RunnableMap {}\n/**\n * A Runnable that can fallback to other Runnables if it fails.\n */\nexport class RunnableWithFallbacks extends Runnable {\n  static lc_name() {\n    return \"RunnableWithFallbacks\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"runnable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fallbacks\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.runnable = fields.runnable;\n    this.fallbacks = fields.fallbacks;\n  }\n  *runnables() {\n    yield this.runnable;\n    for (const fallback of this.fallbacks) {\n      yield fallback;\n    }\n  }\n  async invoke(input, options) {\n    const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n    const {\n      runId,\n      ...otherOptions\n    } = options ?? {};\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherOptions?.runName);\n    let firstError;\n    for (const runnable of this.runnables()) {\n      try {\n        const output = await runnable.invoke(input, patchConfig(otherOptions, {\n          callbacks: runManager?.getChild()\n        }));\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n        return output;\n      } catch (e) {\n        if (firstError === undefined) {\n          firstError = e;\n        }\n      }\n    }\n    if (firstError === undefined) {\n      throw new Error(\"No error stored at end of fallback.\");\n    }\n    await runManager?.handleChainError(firstError);\n    throw firstError;\n  }\n  async batch(inputs, options, batchOptions) {\n    if (batchOptions?.returnExceptions) {\n      throw new Error(\"Not implemented.\");\n    }\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const callbackManagers = await Promise.all(configList.map(config => CallbackManager.configure(config?.callbacks, undefined, config?.tags, undefined, config?.metadata)));\n    const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n      const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n      delete configList[i].runId;\n      return handleStartRes;\n    }));\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let firstError;\n    for (const runnable of this.runnables()) {\n      try {\n        const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => patchConfig(configList[j], {\n          callbacks: runManager?.getChild()\n        })), batchOptions);\n        await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(outputs[i], \"output\"))));\n        return outputs;\n      } catch (e) {\n        if (firstError === undefined) {\n          firstError = e;\n        }\n      }\n    }\n    if (!firstError) {\n      throw new Error(\"No error stored at end of fallbacks.\");\n    }\n    await Promise.all(runManagers.map(runManager => runManager?.handleChainError(firstError)));\n    throw firstError;\n  }\n}\n// TODO: Figure out why the compiler needs help eliminating Error as a RunOutput type\nexport function _coerceToRunnable(coerceable) {\n  if (typeof coerceable === \"function\") {\n    return new RunnableLambda({\n      func: coerceable\n    });\n  } else if (Runnable.isRunnable(coerceable)) {\n    return coerceable;\n  } else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n    const runnables = {};\n    for (const [key, value] of Object.entries(coerceable)) {\n      runnables[key] = _coerceToRunnable(value);\n    }\n    return new RunnableMap({\n      steps: runnables\n    });\n  } else {\n    throw new Error(`Expected a Runnable, function or object.\\nInstead got an unsupported type.`);\n  }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n */\nexport class RunnableAssign extends Runnable {\n  static lc_name() {\n    return \"RunnableAssign\";\n  }\n  constructor(fields) {\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (fields instanceof RunnableMap) {\n      // eslint-disable-next-line no-param-reassign\n      fields = {\n        mapper: fields\n      };\n    }\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"mapper\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.mapper = fields.mapper;\n  }\n  async invoke(input, options) {\n    const mapperResult = await this.mapper.invoke(input, options);\n    return {\n      ...input,\n      ...mapperResult\n    };\n  }\n  async *_transform(generator, runManager, options) {\n    // collect mapper keys\n    const mapperKeys = this.mapper.getStepsKeys();\n    // create two input gens, one for the mapper, one for the input\n    const [forPassthrough, forMapper] = atee(generator);\n    // create mapper output gen\n    const mapperOutput = this.mapper.transform(forMapper, patchConfig(options, {\n      callbacks: runManager?.getChild()\n    }));\n    // start the mapper\n    const firstMapperChunkPromise = mapperOutput.next();\n    // yield the passthrough\n    for await (const chunk of forPassthrough) {\n      if (typeof chunk !== \"object\" || Array.isArray(chunk)) {\n        throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof chunk}`);\n      }\n      const filtered = Object.fromEntries(Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key)));\n      if (Object.keys(filtered).length > 0) {\n        yield filtered;\n      }\n    }\n    // yield the mapper output\n    yield (await firstMapperChunkPromise).value;\n    for await (const chunk of mapperOutput) {\n      yield chunk;\n    }\n  }\n  transform(generator, options) {\n    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n  }\n  async stream(input, options) {\n    async function* generator() {\n      yield input;\n    }\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this.transform(generator(), config),\n      config\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n */\nexport class RunnablePick extends Runnable {\n  static lc_name() {\n    return \"RunnablePick\";\n  }\n  constructor(fields) {\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = {\n        keys: fields\n      };\n    }\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"keys\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.keys = fields.keys;\n  }\n  async _pick(input) {\n    if (typeof this.keys === \"string\") {\n      return input[this.keys];\n    } else {\n      const picked = this.keys.map(key => [key, input[key]]).filter(v => v[1] !== undefined);\n      return picked.length === 0 ? undefined : Object.fromEntries(picked);\n    }\n  }\n  async invoke(input, options) {\n    return this._callWithConfig(this._pick.bind(this), input, options);\n  }\n  async *_transform(generator) {\n    for await (const chunk of generator) {\n      const picked = await this._pick(chunk);\n      if (picked !== undefined) {\n        yield picked;\n      }\n    }\n  }\n  transform(generator, options) {\n    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n  }\n  async stream(input, options) {\n    async function* generator() {\n      yield input;\n    }\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this.transform(generator(), config),\n      config\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}","map":{"version":3,"names":["z","pRetry","v4","uuidv4","isTraceableFunction","CallbackManager","LogStreamCallbackHandler","RunLog","RunLogPatch","isLogStreamHandler","EventStreamCallbackHandler","isStreamEventsHandler","Serializable","IterableReadableStream","concat","atee","pipeGeneratorWithSetup","AsyncGeneratorWithSetup","DEFAULT_RECURSION_LIMIT","ensureConfig","getCallbackManagerForConfig","mergeConfigs","patchConfig","AsyncCaller","RootListenersTracer","_RootEventFilter","isRunnableInterface","AsyncLocalStorageProviderSingleton","Graph","convertToHttpEventStream","consumeAsyncIterableInContext","consumeIteratorInContext","isAsyncIterable","isIterableIterator","isIterator","_coerceToDict","value","defaultKey","Array","isArray","Date","Runnable","constructor","arguments","Object","defineProperty","enumerable","configurable","writable","getName","suffix","name","lc_name","bind","kwargs","RunnableBinding","bound","config","map","RunnableEach","withRetry","fields","RunnableRetry","maxAttemptNumber","stopAfterAttempt","withConfig","withFallbacks","RunnableWithFallbacks","runnable","fallbacks","_getOptionsList","options","length","Error","runId","console","warn","subsequent","fromEntries","entries","filter","key","from","_","i","batch","inputs","batchOptions","configList","maxConcurrency","caller","onFailedAttempt","e","batchCalls","input","call","result","invoke","returnExceptions","Promise","all","_streamIterator","stream","wrappedGenerator","generator","setup","fromAsyncGenerator","_separateRunnableConfigFromCallOptions","runnableConfig","undefined","callbacks","tags","metadata","runName","recursionLimit","callOptions","_callWithConfig","func","callbackManager_","runManager","handleChainStart","toJSON","runType","output","handleChainError","handleChainEnd","_batchWithConfig","optionsList","callbackManagers","runManagers","callbackManager","handleStartRes","outputs","_transformStreamWithConfig","inputGenerator","transformer","finalInput","finalInputSupported","finalOutput","finalOutputSupported","wrapInputForTracing","chunk","pipe","streamEventsHandler","handlers","find","iterator","tapOutputIterable","streamLogHandler","getGraph","graph","inputNode","addNode","schema","any","runnableNode","outputNode","addEdge","coerceable","RunnableSequence","first","last","_coerceToRunnable","pick","keys","RunnablePick","assign","mapping","RunnableAssign","RunnableMap","steps","transform","finalChunk","streamLog","streamOptions","logStreamCallbackHandler","autoClose","_schemaFormat","_streamLog","copiedCallbacks","copy","inheritableHandlers","push","runnableStreamPromise","consumeRunnableStream","runnableStream","patch","ops","op","path","writer","write","close","runnableStreamConsumePromise","log","streamEvents","version","_streamEventsV1","_streamEventsV2","encoding","eventStreamer","outerThis","tappedStream","finish","firstEventSent","firstEventRunId","event","data","run_id","endsWith","runLog","hasEncounteredStartEvent","rootTags","rootMetadata","rootName","rootEventFilter","logStream","fromRunLogPatch","state","id","type","includeEvent","paths","startsWith","split","dedupedPaths","Set","eventType","logEntry","logs","end_time","streamed_output","final_output","chunkCount","isRunnable","thing","withListeners","onStart","onEnd","onError","configFactories","_mergeConfig","configFactory","mergedOptions","individualOption","isRunnableBinding","_invoke","getChild","_patchConfigForRetry","attempt","tag","attemptNumber","error","retries","Math","max","randomize","_batch","configs","resultsMap","remainingIndexes","toString","remainingInputs","patchedConfigs","results","firstException","resultMapIndex","sort","a","b","parseInt","middle","nextStepInput","initialSteps","step","nextStepInputs","j","childRunManager","otherOptions","concatSupported","finalGenerator","currentLastNode","forEach","index","stepGraph","trimFirstNode","trimLastNode","extend","stepFirstNode","firstNode","lastNode","isRunnableSequence","runnables","slice","getStepsKeys","_transform","inputCopies","tasks","Map","gen","next","then","size","race","values","delete","done","set","RunnableTraceable","item","assertNonTraceableFunction","RunnableLambda","resolve","reject","childConfig","getInstance","run","res","RunnableParallel","fallback","configure","firstError","mapper","mapperResult","mapperKeys","forPassthrough","forMapper","mapperOutput","firstMapperChunkPromise","filtered","includes","_pick","picked","v"],"sources":["C:/Users/lucil/Gen-AI-Contest/FrontEnd/kridic-front/node_modules/@langchain/core/dist/runnables/base.js"],"sourcesContent":["import { z } from \"zod\";\nimport pRetry from \"p-retry\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { isTraceableFunction, } from \"langsmith/singletons/traceable\";\nimport { CallbackManager, } from \"../callbacks/manager.js\";\nimport { LogStreamCallbackHandler, RunLog, RunLogPatch, isLogStreamHandler, } from \"../tracers/log_stream.js\";\nimport { EventStreamCallbackHandler, isStreamEventsHandler, } from \"../tracers/event_stream.js\";\nimport { Serializable } from \"../load/serializable.js\";\nimport { IterableReadableStream, concat, atee, pipeGeneratorWithSetup, AsyncGeneratorWithSetup, } from \"../utils/stream.js\";\nimport { DEFAULT_RECURSION_LIMIT, ensureConfig, getCallbackManagerForConfig, mergeConfigs, patchConfig, } from \"./config.js\";\nimport { AsyncCaller } from \"../utils/async_caller.js\";\nimport { RootListenersTracer } from \"../tracers/root_listener.js\";\nimport { _RootEventFilter, isRunnableInterface } from \"./utils.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport { Graph } from \"./graph.js\";\nimport { convertToHttpEventStream } from \"./wrappers.js\";\nimport { consumeAsyncIterableInContext, consumeIteratorInContext, isAsyncIterable, isIterableIterator, isIterator, } from \"./iter.js\";\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function _coerceToDict(value, defaultKey) {\n    return value &&\n        !Array.isArray(value) &&\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        !(value instanceof Date) &&\n        typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\n/**\n * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or\n * transformed.\n */\nexport class Runnable extends Serializable {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    getName(suffix) {\n        const name = \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.name ?? this.constructor.lc_name() ?? this.constructor.name;\n        return suffix ? `${name}${suffix}` : name;\n    }\n    /**\n     * Bind arguments to a Runnable, returning a new Runnable.\n     * @param kwargs\n     * @returns A new RunnableBinding that, when invoked, will apply the bound args.\n     */\n    bind(kwargs) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({ bound: this, kwargs, config: {} });\n    }\n    /**\n     * Return a new Runnable that maps a list of inputs to a list of outputs,\n     * by calling invoke() with each input.\n     */\n    map() {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableEach({ bound: this });\n    }\n    /**\n     * Add retry logic to an existing runnable.\n     * @param kwargs\n     * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.\n     */\n    withRetry(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableRetry({\n            bound: this,\n            kwargs: {},\n            config: {},\n            maxAttemptNumber: fields?.stopAfterAttempt,\n            ...fields,\n        });\n    }\n    /**\n     * Bind config to a Runnable, returning a new Runnable.\n     * @param config New configuration parameters to attach to the new runnable.\n     * @returns A new RunnableBinding with a config matching what's passed.\n     */\n    withConfig(config) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({\n            bound: this,\n            config,\n            kwargs: {},\n        });\n    }\n    /**\n     * Create a new runnable from the current one that will try invoking\n     * other passed fallback runnables if the initial invocation fails.\n     * @param fields.fallbacks Other runnables to call if the runnable errors.\n     * @returns A new RunnableWithFallbacks.\n     */\n    withFallbacks(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableWithFallbacks({\n            runnable: this,\n            fallbacks: fields.fallbacks,\n        });\n    }\n    _getOptionsList(options, length = 0) {\n        if (Array.isArray(options) && options.length !== length) {\n            throw new Error(`Passed \"options\" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);\n        }\n        if (Array.isArray(options)) {\n            return options.map(ensureConfig);\n        }\n        if (length > 1 && !Array.isArray(options) && options.runId) {\n            console.warn(\"Provided runId will be used only for the first element of the batch.\");\n            const subsequent = Object.fromEntries(Object.entries(options).filter(([key]) => key !== \"runId\"));\n            return Array.from({ length }, (_, i) => ensureConfig(i === 0 ? options : subsequent));\n        }\n        return Array.from({ length }, () => ensureConfig(options));\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const maxConcurrency = configList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n        const caller = new AsyncCaller({\n            maxConcurrency,\n            onFailedAttempt: (e) => {\n                throw e;\n            },\n        });\n        const batchCalls = inputs.map((input, i) => caller.call(async () => {\n            try {\n                const result = await this.invoke(input, configList[i]);\n                return result;\n            }\n            catch (e) {\n                if (batchOptions?.returnExceptions) {\n                    return e;\n                }\n                throw e;\n            }\n        }));\n        return Promise.all(batchCalls);\n    }\n    /**\n     * Default streaming implementation.\n     * Subclasses should override this method if they support streaming output.\n     * @param input\n     * @param options\n     */\n    async *_streamIterator(input, options) {\n        yield this.invoke(input, options);\n    }\n    /**\n     * Stream output in chunks.\n     * @param input\n     * @param options\n     * @returns A readable stream that is also an iterable.\n     */\n    async stream(input, options) {\n        // Buffer the first streamed chunk to allow for initial errors\n        // to surface immediately.\n        const config = ensureConfig(options);\n        const wrappedGenerator = new AsyncGeneratorWithSetup({\n            generator: this._streamIterator(input, config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n    _separateRunnableConfigFromCallOptions(options) {\n        let runnableConfig;\n        if (options === undefined) {\n            runnableConfig = ensureConfig(options);\n        }\n        else {\n            runnableConfig = ensureConfig({\n                callbacks: options.callbacks,\n                tags: options.tags,\n                metadata: options.metadata,\n                runName: options.runName,\n                configurable: options.configurable,\n                recursionLimit: options.recursionLimit,\n                maxConcurrency: options.maxConcurrency,\n                runId: options.runId,\n            });\n        }\n        const callOptions = { ...options };\n        delete callOptions.callbacks;\n        delete callOptions.tags;\n        delete callOptions.metadata;\n        delete callOptions.runName;\n        delete callOptions.configurable;\n        delete callOptions.recursionLimit;\n        delete callOptions.maxConcurrency;\n        delete callOptions.runId;\n        return [runnableConfig, callOptions];\n    }\n    async _callWithConfig(func, input, options) {\n        const config = ensureConfig(options);\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, config?.runType, undefined, undefined, config?.runName ?? this.getName());\n        delete config.runId;\n        let output;\n        try {\n            output = await func.call(this, input, config, runManager);\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n        return output;\n    }\n    /**\n     * Internal method that handles batching and configuration for a runnable\n     * It takes a function, input values, and optional configuration, and\n     * returns a promise that resolves to the output values.\n     * @param func The function to be executed for each input value.\n     * @param input The input values to be processed.\n     * @param config Optional configuration for the function execution.\n     * @returns A promise that resolves to the output values.\n     */\n    async _batchWithConfig(func, inputs, options, batchOptions) {\n        const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(optionsList.map(getCallbackManagerForConfig));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), optionsList[i].runId, optionsList[i].runType, undefined, undefined, optionsList[i].runName ?? this.getName());\n            delete optionsList[i].runId;\n            return handleStartRes;\n        }));\n        let outputs;\n        try {\n            outputs = await func.call(this, inputs, optionsList, runManagers, batchOptions);\n        }\n        catch (e) {\n            await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));\n            throw e;\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict(outputs, \"output\"))));\n        return outputs;\n    }\n    /**\n     * Helper method to transform an Iterator of Input values into an Iterator of\n     * Output values, with callbacks.\n     * Use this to implement `stream()` or `transform()` in Runnable subclasses.\n     */\n    async *_transformStreamWithConfig(inputGenerator, transformer, options) {\n        let finalInput;\n        let finalInputSupported = true;\n        let finalOutput;\n        let finalOutputSupported = true;\n        const config = ensureConfig(options);\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        async function* wrapInputForTracing() {\n            for await (const chunk of inputGenerator) {\n                if (finalInputSupported) {\n                    if (finalInput === undefined) {\n                        finalInput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalInput = concat(finalInput, chunk);\n                        }\n                        catch {\n                            finalInput = undefined;\n                            finalInputSupported = false;\n                        }\n                    }\n                }\n                yield chunk;\n            }\n        }\n        let runManager;\n        try {\n            const pipe = await pipeGeneratorWithSetup(transformer.bind(this), wrapInputForTracing(), async () => callbackManager_?.handleChainStart(this.toJSON(), { input: \"\" }, config.runId, config.runType, undefined, undefined, config.runName ?? this.getName()), config);\n            delete config.runId;\n            runManager = pipe.setup;\n            const streamEventsHandler = runManager?.handlers.find(isStreamEventsHandler);\n            let iterator = pipe.output;\n            if (streamEventsHandler !== undefined && runManager !== undefined) {\n                iterator = streamEventsHandler.tapOutputIterable(runManager.runId, iterator);\n            }\n            const streamLogHandler = runManager?.handlers.find(isLogStreamHandler);\n            if (streamLogHandler !== undefined && runManager !== undefined) {\n                iterator = streamLogHandler.tapOutputIterable(runManager.runId, iterator);\n            }\n            for await (const chunk of iterator) {\n                yield chunk;\n                if (finalOutputSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalOutput = concat(finalOutput, chunk);\n                        }\n                        catch {\n                            finalOutput = undefined;\n                            finalOutputSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e, undefined, undefined, undefined, {\n                inputs: _coerceToDict(finalInput, \"input\"),\n            });\n            throw e;\n        }\n        await runManager?.handleChainEnd(finalOutput ?? {}, undefined, undefined, undefined, { inputs: _coerceToDict(finalInput, \"input\") });\n    }\n    getGraph(_) {\n        const graph = new Graph();\n        // TODO: Add input schema for runnables\n        const inputNode = graph.addNode({\n            name: `${this.getName()}Input`,\n            schema: z.any(),\n        });\n        const runnableNode = graph.addNode(this);\n        // TODO: Add output schemas for runnables\n        const outputNode = graph.addNode({\n            name: `${this.getName()}Output`,\n            schema: z.any(),\n        });\n        graph.addEdge(inputNode, runnableNode);\n        graph.addEdge(runnableNode, outputNode);\n        return graph;\n    }\n    /**\n     * Create a new runnable sequence that runs each individual runnable in series,\n     * piping the output of one runnable into another runnable or runnable-like.\n     * @param coerceable A runnable, function, or object whose values are functions or runnables.\n     * @returns A new runnable sequence.\n     */\n    pipe(coerceable) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableSequence({\n            first: this,\n            last: _coerceToRunnable(coerceable),\n        });\n    }\n    /**\n     * Pick keys from the dict output of this runnable. Returns a new runnable.\n     */\n    pick(keys) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return this.pipe(new RunnablePick(keys));\n    }\n    /**\n     * Assigns new fields to the dict output of this runnable. Returns a new runnable.\n     */\n    assign(mapping) {\n        return this.pipe(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new RunnableAssign(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new RunnableMap({ steps: mapping })));\n    }\n    /**\n     * Default implementation of transform, which buffers input and then calls stream.\n     * Subclasses should override this method if they can start producing output while\n     * input is still being generated.\n     * @param generator\n     * @param options\n     */\n    async *transform(generator, options) {\n        let finalChunk;\n        for await (const chunk of generator) {\n            if (finalChunk === undefined) {\n                finalChunk = chunk;\n            }\n            else {\n                // Make a best effort to gather, for any type that supports concat.\n                // This method should throw an error if gathering fails.\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                finalChunk = concat(finalChunk, chunk);\n            }\n        }\n        yield* this._streamIterator(finalChunk, ensureConfig(options));\n    }\n    /**\n     * Stream all output from a runnable, as reported to the callback system.\n     * This includes all inner runs of LLMs, Retrievers, Tools, etc.\n     * Output is streamed as Log objects, which include a list of\n     * jsonpatch ops that describe how the state of the run has changed in each\n     * step, and the final state of the run.\n     * The jsonpatch ops can be applied in order to construct state.\n     * @param input\n     * @param options\n     * @param streamOptions\n     */\n    async *streamLog(input, options, streamOptions) {\n        const logStreamCallbackHandler = new LogStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n            _schemaFormat: \"original\",\n        });\n        const config = ensureConfig(options);\n        yield* this._streamLog(input, logStreamCallbackHandler, config);\n    }\n    async *_streamLog(input, logStreamCallbackHandler, config) {\n        const { callbacks } = config;\n        if (callbacks === undefined) {\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = [logStreamCallbackHandler];\n        }\n        else if (Array.isArray(callbacks)) {\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = callbacks.concat([logStreamCallbackHandler]);\n        }\n        else {\n            const copiedCallbacks = callbacks.copy();\n            copiedCallbacks.inheritableHandlers.push(logStreamCallbackHandler);\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = copiedCallbacks;\n        }\n        const runnableStreamPromise = this.stream(input, config);\n        async function consumeRunnableStream() {\n            try {\n                const runnableStream = await runnableStreamPromise;\n                for await (const chunk of runnableStream) {\n                    const patch = new RunLogPatch({\n                        ops: [\n                            {\n                                op: \"add\",\n                                path: \"/streamed_output/-\",\n                                value: chunk,\n                            },\n                        ],\n                    });\n                    await logStreamCallbackHandler.writer.write(patch);\n                }\n            }\n            finally {\n                await logStreamCallbackHandler.writer.close();\n            }\n        }\n        const runnableStreamConsumePromise = consumeRunnableStream();\n        try {\n            for await (const log of logStreamCallbackHandler) {\n                yield log;\n            }\n        }\n        finally {\n            await runnableStreamConsumePromise;\n        }\n    }\n    streamEvents(input, options, streamOptions) {\n        let stream;\n        if (options.version === \"v1\") {\n            stream = this._streamEventsV1(input, options, streamOptions);\n        }\n        else if (options.version === \"v2\") {\n            stream = this._streamEventsV2(input, options, streamOptions);\n        }\n        else {\n            throw new Error(`Only versions \"v1\" and \"v2\" of the schema are currently supported.`);\n        }\n        if (options.encoding === \"text/event-stream\") {\n            return convertToHttpEventStream(stream);\n        }\n        else {\n            return IterableReadableStream.fromAsyncGenerator(stream);\n        }\n    }\n    async *_streamEventsV2(input, options, streamOptions) {\n        const eventStreamer = new EventStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n        });\n        const config = ensureConfig(options);\n        const runId = config.runId ?? uuidv4();\n        config.runId = runId;\n        const callbacks = config.callbacks;\n        if (callbacks === undefined) {\n            config.callbacks = [eventStreamer];\n        }\n        else if (Array.isArray(callbacks)) {\n            config.callbacks = callbacks.concat(eventStreamer);\n        }\n        else {\n            const copiedCallbacks = callbacks.copy();\n            copiedCallbacks.inheritableHandlers.push(eventStreamer);\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = copiedCallbacks;\n        }\n        // Call the runnable in streaming mode,\n        // add each chunk to the output stream\n        const outerThis = this;\n        async function consumeRunnableStream() {\n            try {\n                const runnableStream = await outerThis.stream(input, config);\n                const tappedStream = eventStreamer.tapOutputIterable(runId, runnableStream);\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                for await (const _ of tappedStream) {\n                    // Just iterate so that the callback handler picks up events\n                }\n            }\n            finally {\n                await eventStreamer.finish();\n            }\n        }\n        const runnableStreamConsumePromise = consumeRunnableStream();\n        let firstEventSent = false;\n        let firstEventRunId;\n        try {\n            for await (const event of eventStreamer) {\n                // This is a work-around an issue where the inputs into the\n                // chain are not available until the entire input is consumed.\n                // As a temporary solution, we'll modify the input to be the input\n                // that was passed into the chain.\n                if (!firstEventSent) {\n                    event.data.input = input;\n                    firstEventSent = true;\n                    firstEventRunId = event.run_id;\n                    yield event;\n                    continue;\n                }\n                if (event.run_id === firstEventRunId && event.event.endsWith(\"_end\")) {\n                    // If it's the end event corresponding to the root runnable\n                    // we dont include the input in the event since it's guaranteed\n                    // to be included in the first event.\n                    if (event.data?.input) {\n                        delete event.data.input;\n                    }\n                }\n                yield event;\n            }\n        }\n        finally {\n            await runnableStreamConsumePromise;\n        }\n    }\n    async *_streamEventsV1(input, options, streamOptions) {\n        let runLog;\n        let hasEncounteredStartEvent = false;\n        const config = ensureConfig(options);\n        const rootTags = config.tags ?? [];\n        const rootMetadata = config.metadata ?? {};\n        const rootName = config.runName ?? this.getName();\n        const logStreamCallbackHandler = new LogStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n            _schemaFormat: \"streaming_events\",\n        });\n        const rootEventFilter = new _RootEventFilter({\n            ...streamOptions,\n        });\n        const logStream = this._streamLog(input, logStreamCallbackHandler, config);\n        for await (const log of logStream) {\n            if (!runLog) {\n                runLog = RunLog.fromRunLogPatch(log);\n            }\n            else {\n                runLog = runLog.concat(log);\n            }\n            if (runLog.state === undefined) {\n                throw new Error(`Internal error: \"streamEvents\" state is missing. Please open a bug report.`);\n            }\n            // Yield the start event for the root runnable if it hasn't been seen.\n            // The root run is never filtered out\n            if (!hasEncounteredStartEvent) {\n                hasEncounteredStartEvent = true;\n                const state = { ...runLog.state };\n                const event = {\n                    run_id: state.id,\n                    event: `on_${state.type}_start`,\n                    name: rootName,\n                    tags: rootTags,\n                    metadata: rootMetadata,\n                    data: {\n                        input,\n                    },\n                };\n                if (rootEventFilter.includeEvent(event, state.type)) {\n                    yield event;\n                }\n            }\n            const paths = log.ops\n                .filter((op) => op.path.startsWith(\"/logs/\"))\n                .map((op) => op.path.split(\"/\")[2]);\n            const dedupedPaths = [...new Set(paths)];\n            for (const path of dedupedPaths) {\n                let eventType;\n                let data = {};\n                const logEntry = runLog.state.logs[path];\n                if (logEntry.end_time === undefined) {\n                    if (logEntry.streamed_output.length > 0) {\n                        eventType = \"stream\";\n                    }\n                    else {\n                        eventType = \"start\";\n                    }\n                }\n                else {\n                    eventType = \"end\";\n                }\n                if (eventType === \"start\") {\n                    // Include the inputs with the start event if they are available.\n                    // Usually they will NOT be available for components that operate\n                    // on streams, since those components stream the input and\n                    // don't know its final value until the end of the stream.\n                    if (logEntry.inputs !== undefined) {\n                        data.input = logEntry.inputs;\n                    }\n                }\n                else if (eventType === \"end\") {\n                    if (logEntry.inputs !== undefined) {\n                        data.input = logEntry.inputs;\n                    }\n                    data.output = logEntry.final_output;\n                }\n                else if (eventType === \"stream\") {\n                    const chunkCount = logEntry.streamed_output.length;\n                    if (chunkCount !== 1) {\n                        throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${logEntry.name}\"`);\n                    }\n                    data = { chunk: logEntry.streamed_output[0] };\n                    // Clean up the stream, we don't need it anymore.\n                    // And this avoids duplicates as well!\n                    logEntry.streamed_output = [];\n                }\n                yield {\n                    event: `on_${logEntry.type}_${eventType}`,\n                    name: logEntry.name,\n                    run_id: logEntry.id,\n                    tags: logEntry.tags,\n                    metadata: logEntry.metadata,\n                    data,\n                };\n            }\n            // Finally, we take care of the streaming output from the root chain\n            // if there is any.\n            const { state } = runLog;\n            if (state.streamed_output.length > 0) {\n                const chunkCount = state.streamed_output.length;\n                if (chunkCount !== 1) {\n                    throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${state.name}\"`);\n                }\n                const data = { chunk: state.streamed_output[0] };\n                // Clean up the stream, we don't need it anymore.\n                state.streamed_output = [];\n                const event = {\n                    event: `on_${state.type}_stream`,\n                    run_id: state.id,\n                    tags: rootTags,\n                    metadata: rootMetadata,\n                    name: rootName,\n                    data,\n                };\n                if (rootEventFilter.includeEvent(event, state.type)) {\n                    yield event;\n                }\n            }\n        }\n        const state = runLog?.state;\n        if (state !== undefined) {\n            // Finally, yield the end event for the root runnable.\n            const event = {\n                event: `on_${state.type}_end`,\n                name: rootName,\n                run_id: state.id,\n                tags: rootTags,\n                metadata: rootMetadata,\n                data: {\n                    output: state.final_output,\n                },\n            };\n            if (rootEventFilter.includeEvent(event, state.type))\n                yield event;\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnable(thing) {\n        return isRunnableInterface(thing);\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({\n            bound: this,\n            config: {},\n            configFactories: [\n                (config) => ({\n                    callbacks: [\n                        new RootListenersTracer({\n                            config,\n                            onStart,\n                            onEnd,\n                            onError,\n                        }),\n                    ],\n                }),\n            ],\n        });\n    }\n}\n/**\n * A runnable that delegates calls to another runnable with a set of kwargs.\n */\nexport class RunnableBinding extends Runnable {\n    static lc_name() {\n        return \"RunnableBinding\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"configFactories\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.bound = fields.bound;\n        this.kwargs = fields.kwargs;\n        this.config = fields.config;\n        this.configFactories = fields.configFactories;\n    }\n    getName(suffix) {\n        return this.bound.getName(suffix);\n    }\n    async _mergeConfig(...options) {\n        const config = mergeConfigs(this.config, ...options);\n        return mergeConfigs(config, ...(this.configFactories\n            ? await Promise.all(this.configFactories.map(async (configFactory) => await configFactory(config)))\n            : []));\n    }\n    bind(kwargs) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return new this.constructor({\n            bound: this.bound,\n            kwargs: { ...this.kwargs, ...kwargs },\n            config: this.config,\n        });\n    }\n    withConfig(config) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return new this.constructor({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: { ...this.config, ...config },\n        });\n    }\n    withRetry(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return new this.constructor({\n            bound: this.bound.withRetry(fields),\n            kwargs: this.kwargs,\n            config: this.config,\n        });\n    }\n    async invoke(input, options) {\n        return this.bound.invoke(input, await this._mergeConfig(ensureConfig(options), this.kwargs));\n    }\n    async batch(inputs, options, batchOptions) {\n        const mergedOptions = Array.isArray(options)\n            ? await Promise.all(options.map(async (individualOption) => this._mergeConfig(ensureConfig(individualOption), this.kwargs)))\n            : await this._mergeConfig(ensureConfig(options), this.kwargs);\n        return this.bound.batch(inputs, mergedOptions, batchOptions);\n    }\n    async *_streamIterator(input, options) {\n        yield* this.bound._streamIterator(input, await this._mergeConfig(ensureConfig(options), this.kwargs));\n    }\n    async stream(input, options) {\n        return this.bound.stream(input, await this._mergeConfig(ensureConfig(options), this.kwargs));\n    }\n    async *transform(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    generator, options) {\n        yield* this.bound.transform(generator, await this._mergeConfig(ensureConfig(options), this.kwargs));\n    }\n    streamEvents(input, options, streamOptions) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const outerThis = this;\n        const generator = async function* () {\n            yield* outerThis.bound.streamEvents(input, {\n                ...(await outerThis._mergeConfig(ensureConfig(options), outerThis.kwargs)),\n                version: options.version,\n            }, streamOptions);\n        };\n        return IterableReadableStream.fromAsyncGenerator(generator());\n    }\n    static isRunnableBinding(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    thing\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        return thing.bound && Runnable.isRunnable(thing.bound);\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        return new RunnableBinding({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: this.config,\n            configFactories: [\n                (config) => ({\n                    callbacks: [\n                        new RootListenersTracer({\n                            config,\n                            onStart,\n                            onEnd,\n                            onError,\n                        }),\n                    ],\n                }),\n            ],\n        });\n    }\n}\n/**\n * A runnable that delegates calls to another runnable\n * with each element of the input sequence.\n */\nexport class RunnableEach extends Runnable {\n    static lc_name() {\n        return \"RunnableEach\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.bound = fields.bound;\n    }\n    /**\n     * Binds the runnable with the specified arguments.\n     * @param kwargs The arguments to bind the runnable with.\n     * @returns A new instance of the `RunnableEach` class that is bound with the specified arguments.\n     */\n    bind(kwargs) {\n        return new RunnableEach({\n            bound: this.bound.bind(kwargs),\n        });\n    }\n    /**\n     * Invokes the runnable with the specified input and configuration.\n     * @param input The input to invoke the runnable with.\n     * @param config The configuration to invoke the runnable with.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async invoke(inputs, config) {\n        return this._callWithConfig(this._invoke, inputs, config);\n    }\n    /**\n     * A helper method that is used to invoke the runnable with the specified input and configuration.\n     * @param input The input to invoke the runnable with.\n     * @param config The configuration to invoke the runnable with.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async _invoke(inputs, config, runManager) {\n        return this.bound.batch(inputs, patchConfig(config, { callbacks: runManager?.getChild() }));\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        return new RunnableEach({\n            bound: this.bound.withListeners({ onStart, onEnd, onError }),\n        });\n    }\n}\n/**\n * Base class for runnables that can be retried a\n * specified number of times.\n */\nexport class RunnableRetry extends RunnableBinding {\n    static lc_name() {\n        return \"RunnableRetry\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"maxAttemptNumber\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 3\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"onFailedAttempt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: () => { }\n        });\n        this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;\n        this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;\n    }\n    _patchConfigForRetry(attempt, config, runManager) {\n        const tag = attempt > 1 ? `retry:attempt:${attempt}` : undefined;\n        return patchConfig(config, { callbacks: runManager?.getChild(tag) });\n    }\n    async _invoke(input, config, runManager) {\n        return pRetry((attemptNumber) => super.invoke(input, this._patchConfigForRetry(attemptNumber, config, runManager)), {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onFailedAttempt: (error) => this.onFailedAttempt(error, input),\n            retries: Math.max(this.maxAttemptNumber - 1, 0),\n            randomize: true,\n        });\n    }\n    /**\n     * Method that invokes the runnable with the specified input, run manager,\n     * and config. It handles the retry logic by catching any errors and\n     * recursively invoking itself with the updated config for the next retry\n     * attempt.\n     * @param input The input for the runnable.\n     * @param runManager The run manager for the runnable.\n     * @param config The config for the runnable.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async invoke(input, config) {\n        return this._callWithConfig(this._invoke, input, config);\n    }\n    async _batch(inputs, configs, runManagers, batchOptions) {\n        const resultsMap = {};\n        try {\n            await pRetry(async (attemptNumber) => {\n                const remainingIndexes = inputs\n                    .map((_, i) => i)\n                    .filter((i) => resultsMap[i.toString()] === undefined ||\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    resultsMap[i.toString()] instanceof Error);\n                const remainingInputs = remainingIndexes.map((i) => inputs[i]);\n                const patchedConfigs = remainingIndexes.map((i) => this._patchConfigForRetry(attemptNumber, configs?.[i], runManagers?.[i]));\n                const results = await super.batch(remainingInputs, patchedConfigs, {\n                    ...batchOptions,\n                    returnExceptions: true,\n                });\n                let firstException;\n                for (let i = 0; i < results.length; i += 1) {\n                    const result = results[i];\n                    const resultMapIndex = remainingIndexes[i];\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    if (result instanceof Error) {\n                        if (firstException === undefined) {\n                            firstException = result;\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            firstException.input = remainingInputs[i];\n                        }\n                    }\n                    resultsMap[resultMapIndex.toString()] = result;\n                }\n                if (firstException) {\n                    throw firstException;\n                }\n                return results;\n            }, {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                onFailedAttempt: (error) => this.onFailedAttempt(error, error.input),\n                retries: Math.max(this.maxAttemptNumber - 1, 0),\n                randomize: true,\n            });\n        }\n        catch (e) {\n            if (batchOptions?.returnExceptions !== true) {\n                throw e;\n            }\n        }\n        return Object.keys(resultsMap)\n            .sort((a, b) => parseInt(a, 10) - parseInt(b, 10))\n            .map((key) => resultsMap[parseInt(key, 10)]);\n    }\n    async batch(inputs, options, batchOptions) {\n        return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);\n    }\n}\n/**\n * A sequence of runnables, where the output of each is the input of the next.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n * const chain = RunnableSequence.from([promptTemplate, new ChatOpenAI({})]);\n * const result = await chain.invoke({ topic: \"bears\" });\n * ```\n */\nexport class RunnableSequence extends Runnable {\n    static lc_name() {\n        return \"RunnableSequence\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"first\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"middle\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"last\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        this.first = fields.first;\n        this.middle = fields.middle ?? this.middle;\n        this.last = fields.last;\n        this.name = fields.name;\n    }\n    get steps() {\n        return [this.first, ...this.middle, this.last];\n    }\n    async invoke(input, options) {\n        const config = ensureConfig(options);\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, undefined, undefined, undefined, config?.runName);\n        delete config.runId;\n        let nextStepInput = input;\n        let finalOutput;\n        try {\n            const initialSteps = [this.first, ...this.middle];\n            for (let i = 0; i < initialSteps.length; i += 1) {\n                const step = initialSteps[i];\n                nextStepInput = await step.invoke(nextStepInput, patchConfig(config, {\n                    callbacks: runManager?.getChild(`seq:step:${i + 1}`),\n                }));\n            }\n            // TypeScript can't detect that the last output of the sequence returns RunOutput, so call it out of the loop here\n            finalOutput = await this.last.invoke(nextStepInput, patchConfig(config, {\n                callbacks: runManager?.getChild(`seq:step:${this.steps.length}`),\n            }));\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n        return finalOutput;\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map(getCallbackManagerForConfig));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n            delete configList[i].runId;\n            return handleStartRes;\n        }));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let nextStepInputs = inputs;\n        try {\n            for (let i = 0; i < this.steps.length; i += 1) {\n                const step = this.steps[i];\n                nextStepInputs = await step.batch(nextStepInputs, runManagers.map((runManager, j) => {\n                    const childRunManager = runManager?.getChild(`seq:step:${i + 1}`);\n                    return patchConfig(configList[j], { callbacks: childRunManager });\n                }), batchOptions);\n            }\n        }\n        catch (e) {\n            await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));\n            throw e;\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict(nextStepInputs, \"output\"))));\n        return nextStepInputs;\n    }\n    async *_streamIterator(input, options) {\n        const callbackManager_ = await getCallbackManagerForConfig(options);\n        const { runId, ...otherOptions } = options ?? {};\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherOptions?.runName);\n        const steps = [this.first, ...this.middle, this.last];\n        let concatSupported = true;\n        let finalOutput;\n        async function* inputGenerator() {\n            yield input;\n        }\n        try {\n            let finalGenerator = steps[0].transform(inputGenerator(), patchConfig(otherOptions, {\n                callbacks: runManager?.getChild(`seq:step:1`),\n            }));\n            for (let i = 1; i < steps.length; i += 1) {\n                const step = steps[i];\n                finalGenerator = await step.transform(finalGenerator, patchConfig(otherOptions, {\n                    callbacks: runManager?.getChild(`seq:step:${i + 1}`),\n                }));\n            }\n            for await (const chunk of finalGenerator) {\n                yield chunk;\n                if (concatSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalOutput = concat(finalOutput, chunk);\n                        }\n                        catch (e) {\n                            finalOutput = undefined;\n                            concatSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n    }\n    getGraph(config) {\n        const graph = new Graph();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let currentLastNode = null;\n        this.steps.forEach((step, index) => {\n            const stepGraph = step.getGraph(config);\n            if (index !== 0) {\n                stepGraph.trimFirstNode();\n            }\n            if (index !== this.steps.length - 1) {\n                stepGraph.trimLastNode();\n            }\n            graph.extend(stepGraph);\n            const stepFirstNode = stepGraph.firstNode();\n            if (!stepFirstNode) {\n                throw new Error(`Runnable ${step} has no first node`);\n            }\n            if (currentLastNode) {\n                graph.addEdge(currentLastNode, stepFirstNode);\n            }\n            currentLastNode = stepGraph.lastNode();\n        });\n        return graph;\n    }\n    pipe(coerceable) {\n        if (RunnableSequence.isRunnableSequence(coerceable)) {\n            return new RunnableSequence({\n                first: this.first,\n                middle: this.middle.concat([\n                    this.last,\n                    coerceable.first,\n                    ...coerceable.middle,\n                ]),\n                last: coerceable.last,\n                name: this.name ?? coerceable.name,\n            });\n        }\n        else {\n            return new RunnableSequence({\n                first: this.first,\n                middle: [...this.middle, this.last],\n                last: _coerceToRunnable(coerceable),\n                name: this.name,\n            });\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnableSequence(thing) {\n        return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static from([first, ...runnables], name) {\n        return new RunnableSequence({\n            first: _coerceToRunnable(first),\n            middle: runnables.slice(0, -1).map(_coerceToRunnable),\n            last: _coerceToRunnable(runnables[runnables.length - 1]),\n            name,\n        });\n    }\n}\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * const mapChain = RunnableMap.from({\n *   joke: PromptTemplate.fromTemplate(\"Tell me a joke about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n *   poem: PromptTemplate.fromTemplate(\"write a 2-line poem about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n * });\n * const result = await mapChain.invoke({ topic: \"bear\" });\n * ```\n */\nexport class RunnableMap extends Runnable {\n    static lc_name() {\n        return \"RunnableMap\";\n    }\n    getStepsKeys() {\n        return Object.keys(this.steps);\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"steps\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.steps = {};\n        for (const [key, value] of Object.entries(fields.steps)) {\n            this.steps[key] = _coerceToRunnable(value);\n        }\n    }\n    static from(steps) {\n        return new RunnableMap({ steps });\n    }\n    async invoke(input, options) {\n        const config = ensureConfig(options);\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), {\n            input,\n        }, config.runId, undefined, undefined, undefined, config?.runName);\n        delete config.runId;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const output = {};\n        try {\n            await Promise.all(Object.entries(this.steps).map(async ([key, runnable]) => {\n                output[key] = await runnable.invoke(input, patchConfig(config, {\n                    callbacks: runManager?.getChild(`map:key:${key}`),\n                }));\n            }));\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(output);\n        return output;\n    }\n    async *_transform(generator, runManager, options) {\n        // shallow copy steps to ignore changes while iterating\n        const steps = { ...this.steps };\n        // each step gets a copy of the input iterator\n        const inputCopies = atee(generator, Object.keys(steps).length);\n        // start the first iteration of each output iterator\n        const tasks = new Map(Object.entries(steps).map(([key, runnable], i) => {\n            const gen = runnable.transform(inputCopies[i], patchConfig(options, {\n                callbacks: runManager?.getChild(`map:key:${key}`),\n            }));\n            return [key, gen.next().then((result) => ({ key, gen, result }))];\n        }));\n        // yield chunks as they become available,\n        // starting new iterations as needed,\n        // until all iterators are done\n        while (tasks.size) {\n            const { key, result, gen } = await Promise.race(tasks.values());\n            tasks.delete(key);\n            if (!result.done) {\n                yield { [key]: result.value };\n                tasks.set(key, gen.next().then((result) => ({ key, gen, result })));\n            }\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = ensureConfig(options);\n        const wrappedGenerator = new AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\n/**\n * A runnable that wraps a traced LangSmith function.\n */\nexport class RunnableTraceable extends Runnable {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (!isTraceableFunction(fields.func)) {\n            throw new Error(\"RunnableTraceable requires a function that is wrapped in traceable higher-order function\");\n        }\n        this.func = fields.func;\n    }\n    async invoke(input, options) {\n        const [config] = this._getOptionsList(options ?? {}, 1);\n        const callbacks = await getCallbackManagerForConfig(config);\n        return (await this.func(patchConfig(config, { callbacks }), input));\n    }\n    async *_streamIterator(input, options) {\n        const result = await this.invoke(input, options);\n        if (isAsyncIterable(result)) {\n            for await (const item of result) {\n                yield item;\n            }\n            return;\n        }\n        if (isIterator(result)) {\n            while (true) {\n                const state = result.next();\n                if (state.done)\n                    break;\n                yield state.value;\n            }\n            return;\n        }\n        yield result;\n    }\n    static from(func) {\n        return new RunnableTraceable({ func });\n    }\n}\nfunction assertNonTraceableFunction(func) {\n    if (isTraceableFunction(func)) {\n        throw new Error(\"RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.\");\n    }\n}\n/**\n * A runnable that runs a callable.\n */\nexport class RunnableLambda extends Runnable {\n    static lc_name() {\n        return \"RunnableLambda\";\n    }\n    constructor(fields) {\n        if (isTraceableFunction(fields.func)) {\n            // eslint-disable-next-line no-constructor-return\n            return RunnableTraceable.from(fields.func);\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        assertNonTraceableFunction(fields.func);\n        this.func = fields.func;\n    }\n    static from(func) {\n        return new RunnableLambda({\n            func,\n        });\n    }\n    async _invoke(input, config, runManager) {\n        return new Promise((resolve, reject) => {\n            const childConfig = patchConfig(config, {\n                callbacks: runManager?.getChild(),\n                recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1,\n            });\n            void AsyncLocalStorageProviderSingleton.getInstance().run(childConfig, async () => {\n                try {\n                    let output = await this.func(input, {\n                        ...childConfig,\n                        config: childConfig,\n                    });\n                    if (output && Runnable.isRunnable(output)) {\n                        if (config?.recursionLimit === 0) {\n                            throw new Error(\"Recursion limit reached.\");\n                        }\n                        output = await output.invoke(input, {\n                            ...childConfig,\n                            recursionLimit: (childConfig.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1,\n                        });\n                    }\n                    else if (isAsyncIterable(output)) {\n                        let finalOutput;\n                        for await (const chunk of consumeAsyncIterableInContext(childConfig, output)) {\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                // Make a best effort to gather, for any type that supports concat.\n                                try {\n                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                    finalOutput = concat(finalOutput, chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = chunk;\n                                }\n                            }\n                        }\n                        output = finalOutput;\n                    }\n                    else if (isIterableIterator(output)) {\n                        let finalOutput;\n                        for (const chunk of consumeIteratorInContext(childConfig, output)) {\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                // Make a best effort to gather, for any type that supports concat.\n                                try {\n                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                    finalOutput = concat(finalOutput, chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = chunk;\n                                }\n                            }\n                        }\n                        output = finalOutput;\n                    }\n                    resolve(output);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(this._invoke, input, options);\n    }\n    async *_transform(generator, runManager, config) {\n        let finalChunk;\n        for await (const chunk of generator) {\n            if (finalChunk === undefined) {\n                finalChunk = chunk;\n            }\n            else {\n                // Make a best effort to gather, for any type that supports concat.\n                try {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    finalChunk = concat(finalChunk, chunk);\n                }\n                catch (e) {\n                    finalChunk = chunk;\n                }\n            }\n        }\n        const output = await new Promise((resolve, reject) => {\n            void AsyncLocalStorageProviderSingleton.getInstance().run(config, async () => {\n                try {\n                    const res = await this.func(finalChunk, {\n                        ...config,\n                        config,\n                    });\n                    resolve(res);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n        if (output && Runnable.isRunnable(output)) {\n            if (config?.recursionLimit === 0) {\n                throw new Error(\"Recursion limit reached.\");\n            }\n            const stream = await output.stream(finalChunk, patchConfig(config, {\n                callbacks: runManager?.getChild(),\n                recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1,\n            }));\n            for await (const chunk of stream) {\n                yield chunk;\n            }\n        }\n        else if (isAsyncIterable(output)) {\n            for await (const chunk of consumeAsyncIterableInContext(config, output)) {\n                yield chunk;\n            }\n        }\n        else if (isIterableIterator(output)) {\n            for (const chunk of consumeIteratorInContext(config, output)) {\n                yield chunk;\n            }\n        }\n        else {\n            yield output;\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = ensureConfig(options);\n        const wrappedGenerator = new AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\nexport class RunnableParallel extends RunnableMap {\n}\n/**\n * A Runnable that can fallback to other Runnables if it fails.\n */\nexport class RunnableWithFallbacks extends Runnable {\n    static lc_name() {\n        return \"RunnableWithFallbacks\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fallbacks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnable = fields.runnable;\n        this.fallbacks = fields.fallbacks;\n    }\n    *runnables() {\n        yield this.runnable;\n        for (const fallback of this.fallbacks) {\n            yield fallback;\n        }\n    }\n    async invoke(input, options) {\n        const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n        const { runId, ...otherOptions } = options ?? {};\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherOptions?.runName);\n        let firstError;\n        for (const runnable of this.runnables()) {\n            try {\n                const output = await runnable.invoke(input, patchConfig(otherOptions, { callbacks: runManager?.getChild() }));\n                await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n                return output;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (firstError === undefined) {\n            throw new Error(\"No error stored at end of fallback.\");\n        }\n        await runManager?.handleChainError(firstError);\n        throw firstError;\n    }\n    async batch(inputs, options, batchOptions) {\n        if (batchOptions?.returnExceptions) {\n            throw new Error(\"Not implemented.\");\n        }\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map((config) => CallbackManager.configure(config?.callbacks, undefined, config?.tags, undefined, config?.metadata)));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n            delete configList[i].runId;\n            return handleStartRes;\n        }));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let firstError;\n        for (const runnable of this.runnables()) {\n            try {\n                const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => patchConfig(configList[j], {\n                    callbacks: runManager?.getChild(),\n                })), batchOptions);\n                await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(outputs[i], \"output\"))));\n                return outputs;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (!firstError) {\n            throw new Error(\"No error stored at end of fallbacks.\");\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(firstError)));\n        throw firstError;\n    }\n}\n// TODO: Figure out why the compiler needs help eliminating Error as a RunOutput type\nexport function _coerceToRunnable(coerceable) {\n    if (typeof coerceable === \"function\") {\n        return new RunnableLambda({ func: coerceable });\n    }\n    else if (Runnable.isRunnable(coerceable)) {\n        return coerceable;\n    }\n    else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n        const runnables = {};\n        for (const [key, value] of Object.entries(coerceable)) {\n            runnables[key] = _coerceToRunnable(value);\n        }\n        return new RunnableMap({\n            steps: runnables,\n        });\n    }\n    else {\n        throw new Error(`Expected a Runnable, function or object.\\nInstead got an unsupported type.`);\n    }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n */\nexport class RunnableAssign extends Runnable {\n    static lc_name() {\n        return \"RunnableAssign\";\n    }\n    constructor(fields) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (fields instanceof RunnableMap) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { mapper: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"mapper\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.mapper = fields.mapper;\n    }\n    async invoke(input, options) {\n        const mapperResult = await this.mapper.invoke(input, options);\n        return {\n            ...input,\n            ...mapperResult,\n        };\n    }\n    async *_transform(generator, runManager, options) {\n        // collect mapper keys\n        const mapperKeys = this.mapper.getStepsKeys();\n        // create two input gens, one for the mapper, one for the input\n        const [forPassthrough, forMapper] = atee(generator);\n        // create mapper output gen\n        const mapperOutput = this.mapper.transform(forMapper, patchConfig(options, { callbacks: runManager?.getChild() }));\n        // start the mapper\n        const firstMapperChunkPromise = mapperOutput.next();\n        // yield the passthrough\n        for await (const chunk of forPassthrough) {\n            if (typeof chunk !== \"object\" || Array.isArray(chunk)) {\n                throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof chunk}`);\n            }\n            const filtered = Object.fromEntries(Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key)));\n            if (Object.keys(filtered).length > 0) {\n                yield filtered;\n            }\n        }\n        // yield the mapper output\n        yield (await firstMapperChunkPromise).value;\n        for await (const chunk of mapperOutput) {\n            yield chunk;\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = ensureConfig(options);\n        const wrappedGenerator = new AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n */\nexport class RunnablePick extends Runnable {\n    static lc_name() {\n        return \"RunnablePick\";\n    }\n    constructor(fields) {\n        if (typeof fields === \"string\" || Array.isArray(fields)) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { keys: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"keys\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.keys = fields.keys;\n    }\n    async _pick(input) {\n        if (typeof this.keys === \"string\") {\n            return input[this.keys];\n        }\n        else {\n            const picked = this.keys\n                .map((key) => [key, input[key]])\n                .filter((v) => v[1] !== undefined);\n            return picked.length === 0 ? undefined : Object.fromEntries(picked);\n        }\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(this._pick.bind(this), input, options);\n    }\n    async *_transform(generator) {\n        for await (const chunk of generator) {\n            const picked = await this._pick(chunk);\n            if (picked !== undefined) {\n                yield picked;\n            }\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = ensureConfig(options);\n        const wrappedGenerator = new AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}