"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Path = require("path");
const slash = require("slash");
const Debugger = require("debug");
const isStream = require("is-stream");
const stream_1 = require("stream");
const debug = Debugger('fsd');
class FSDFile {
    constructor(path, adapter, metadata) {
        debug('initialize file %s', path);
        if (!path)
            throw new Error('FSD File must initialize with path');
        if (typeof path === 'object' && path.path) {
            ({ path } = path);
        }
        if (path[0] !== '/') {
            path = `/${path}`;
        }
        this.instanceOfFSDFile = true;
        this._adapter = adapter;
        this.needEnsureDir = adapter.needEnsureDir;
        this.path = path;
        let info = Path.parse(path);
        this.dir = info.dir;
        if (this.dir !== '/') {
            this.dir += '/';
        }
        this.base = info.base;
        this.name = info.name;
        this.ext = info.ext;
        metadata = metadata || {};
        this._size = typeof metadata.size === 'number' ? metadata.size : null;
        this._lastModified = metadata.lastModified || null;
    }
    append(data) {
        debug('append %s', this.path);
        if (this.path.endsWith('/')) {
            throw new Error('append failed, file path should not ends with /');
        }
        this._size = null;
        this._lastModified = null;
        return this._adapter.append(this.path, data);
    }
    async read(position, length, encoding) {
        debug('read %s', this.path);
        if (this.path.endsWith('/')) {
            throw new Error('read failed, file path should not ends with /');
        }
        if (position && typeof position === 'string') {
            encoding = position;
            position = 0;
            length = 0;
        }
        let options = {};
        if (position || position === 0) {
            options.start = position;
        }
        if (length) {
            options.end = position + length - 1;
        }
        let stream = await this._adapter.createReadStream(this.path, options);
        return await new Promise((resolve, reject) => {
            let buffers = [];
            stream.on('error', reject);
            stream.on('data', (data) => buffers.push(data));
            stream.on('end', () => {
                let buf = Buffer.concat(buffers);
                if (encoding) {
                    resolve(buf.toString(encoding));
                }
                else {
                    resolve(buf);
                }
            });
        });
    }
    async write(data) {
        debug('write %s', this.path);
        if (this.path.endsWith('/')) {
            throw new Error('write failed, file path should not ends with /');
        }
        this._size = null;
        this._lastModified = null;
        let stream = await this._adapter.createWriteStream(this.path);
        if (stream.promise) {
            if (isStream.readable(data)) {
                data.pipe(stream);
            }
            else {
                stream.end(data);
            }
            await stream.promise;
            return;
        }
        await new Promise((resolve, reject) => {
            stream.on('error', reject);
            stream.on('finish', resolve);
            if (isStream.readable(data)) {
                data.pipe(stream);
            }
            else {
                stream.end(data);
            }
        });
    }
    createReadStream(options) {
        debug('createReadStream %s', this.path);
        if (this.path.endsWith('/')) {
            throw new Error('createReadStream failed, file path should not ends with /');
        }
        return this._adapter.createReadStream(this.path, options);
    }
    createWriteStream(options) {
        debug('createWriteStream %s', this.path);
        if (this.path.endsWith('/')) {
            throw new Error('createReadStream failed, file path should not ends with /');
        }
        this._size = null;
        this._lastModified = null;
        return this._adapter.createWriteStream(this.path, options);
    }
    unlink() {
        debug('unlink %s', this.path);
        this._size = null;
        this._lastModified = null;
        return this._adapter.unlink(this.path);
    }
    mkdir(recursive) {
        debug('mkdir %s', this.path);
        if (!this.path.endsWith('/')) {
            throw new Error('mkdir failed, directory path should be ends with /');
        }
        this._size = null;
        this._lastModified = null;
        return this._adapter.mkdir(this.path, recursive);
    }
    async readdir(recursion) {
        debug('readdir %s', this.path);
        if (!this.path.endsWith('/')) {
            throw new Error('readdir failed, directory path should be ends with /');
        }
        let files = await this._adapter.readdir(this.path, recursion);
        return files.map(({ name, metadata }) => {
            let path = slash(Path.join(this.path, name));
            return new FSDFile(path, this._adapter, metadata);
        });
    }
    createUrl(options) {
        debug('createUrl %s', this.path);
        return this._adapter.createUrl(this.path, options);
    }
    async copy(dest) {
        debug('copy %s to %s', this.path, dest);
        if (!Path.isAbsolute(dest)) {
            dest = slash(Path.join(Path.dirname(this.path), dest));
        }
        if (dest === this.path) {
            throw new Error('copy failed, dest path should not equal to source path');
        }
        if (this.path.endsWith('/') && !dest.endsWith('/')) {
            throw new Error('copy failed, dest path should be ends with /');
        }
        else if (!this.path.endsWith('/') && dest.endsWith('/')) {
            throw new Error('copy failed, dest path should not ends with /');
        }
        await this._adapter.copy(this.path, dest);
        return new FSDFile(dest, this._adapter);
    }
    rename(dest) {
        debug('rename %s to %s', this.path, dest);
        if (dest === this.path) {
            throw new Error('rename failed, dest path should not equal to source path');
        }
        if (this.path.endsWith('/') && !dest.endsWith('/')) {
            throw new Error('copy failed, dest path should be ends with /');
        }
        else if (!this.path.endsWith('/') && dest.endsWith('/')) {
            throw new Error('copy failed, dest path should not ends with /');
        }
        this._size = null;
        this._lastModified = null;
        return this._adapter.rename(this.path, dest);
    }
    exists() {
        debug('check exists %s', this.path);
        return this._adapter.exists(this.path);
    }
    isFile() {
        debug('check is file %s', this.path);
        if (this.path.endsWith('/')) {
            throw new Error('isFile failed, file path should not ends with /');
        }
        return this._adapter.isFile(this.path);
    }
    isDirectory() {
        debug('check is directory %s', this.path);
        if (!this.path.endsWith('/')) {
            throw new Error('isDirectory failed, file path should be ends with /');
        }
        return this._adapter.isDirectory(this.path);
    }
    async size() {
        if (this.path.endsWith('/'))
            return 0;
        if (typeof this._size !== 'number') {
            this._size = await this._adapter.size(this.path);
        }
        return this._size;
    }
    async lastModified() {
        if (!this._lastModified) {
            this._lastModified = await this._adapter.lastModified(this.path);
        }
        return this._lastModified;
    }
    async initMultipartUpload(partCount) {
        debug('initMultipartUpload %s, partCount: %d', this.path, partCount);
        if (this.path.endsWith('/')) {
            throw new Error('initMultipartUpload failed, file path should not ends with /');
        }
        return this._adapter.initMultipartUpload(this.path, partCount);
    }
    writePart(task, data, size) {
        debug('writePart %s, task: %s', this.path, task);
        if (this.path.endsWith('/')) {
            throw new Error('writePart failed, file path should not ends with /');
        }
        if (!task.startsWith('task:'))
            throw new Error('Invalid task link');
        let stream;
        if (isStream.readable(data)) {
            stream = data;
        }
        else {
            if (typeof data === 'string') {
                data = Buffer.from(data);
            }
            size = data.length;
            stream = new stream_1.PassThrough();
            stream.end(data);
        }
        return this._adapter.writePart(this.path, task, stream, size);
    }
    completeMultipartUpload(parts) {
        debug('completeMultipartUpload %s', this.path);
        if (this.path.endsWith('/')) {
            throw new Error('completeMultipartUpload failed, file path should not ends with /');
        }
        this._size = null;
        this._lastModified = null;
        return this._adapter.completeMultipartUpload(this.path, parts);
    }
    toString() {
        return this.path;
    }
    toJSON() {
        return this.path;
    }
}
exports.default = FSDFile;
